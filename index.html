<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geavanceerd Swingtrade Dashboard v2.7</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0;
            background-color: #f0f2f5; color: #333; padding: 12px;
        }
        .dashboard-header { text-align: center; margin-bottom: 12px; }
        .dashboard-header h1 { margin-bottom: 4px; color: #1f2937; font-size: 1.7em; }
        .dashboard-header p { font-size: 0.85em; color: #6b7280; margin-top:0; }

        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(330px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .card { background-color: #fff; border-radius: 8px; padding: 18px; box-shadow: 0 3px 5px rgba(0,0,0,0.05); }
        .card h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; color: #374151; border-bottom: 1px solid #e5e7eb; padding-bottom: 10px; }

        .indicator { padding: 9px 11px; margin-bottom: 9px; border-radius: 5px; font-size: 0.9em; border: 1px solid transparent; }
        .indicator strong { display: block; margin-bottom: 3px; color: #111827; font-weight: 600; font-size:0.93em; }
        .indicator span { font-size: 0.83em; color: #4b5563; }

        .green { background-color: #dcfce7; border-color: #86efac; border-left: 4px solid #22c55e; }
        .yellow { background-color: #fef9c3; border-color: #fde047; border-left: 4px solid #eab308; }
        .red { background-color: #fee2e2; border-color: #fca5a5; border-left: 4px solid #ef4444; }
        .neutral { background-color: #f3f4f6; border-color: #d1d5db; border-left: 4px solid #6b7280; }

        .crypto-market-card .indicator.yellow {
            background-color: #fef3c7; border-color: #f59e0b;
            border-left-width: 4px; border-left-color: #f59e0b;
        }
        .crypto-market-card .indicator.yellow strong,
        .crypto-market-card .indicator.yellow span { color: #78350f; }

        .condition-card {
            color: white; padding: 18px; border-radius: 8px; text-align: center;
            box-shadow: 0 4px 7px rgba(0,0,0,0.1); margin-bottom: 15px;
        }
        .condition-card h2 { margin-top: 0; color: white; border-bottom: none; font-size: 1.3em; }
        .condition-card p.status-text { font-size: 1.05em; margin-bottom: 8px; font-weight: bold; }
        .condition-card .factors-title { font-size: 0.75em; margin-top:10px; margin-bottom:3px; text-transform: uppercase; opacity:0.85; font-weight:600;}
        .condition-card .factors-list { font-size: 0.75em; opacity: 0.95; list-style-type: none; padding-left:0; margin:0 auto; max-width: 95%;}
        .condition-card .factors-list li { margin-bottom: 2px; text-align: left; padding-left: 5px; border-radius:3px; padding-top:1px; padding-bottom:1px;}
        .condition-card .factors-list li:hover { background-color: rgba(0,0,0,0.05); }
        .factors-list .factor-positive::before { content: 'ðŸŸ¢ '; font-size:0.75em; }
        .factors-list .factor-negative::before { content: 'ðŸ”´ '; font-size:0.75em; }

        .very-positive { background-color: #16a34a; } .positive { background-color: #22c55e; }
        .negative { background-color: #f97316; } .very-negative { background-color: #dc2626; }
        .condition-neutral { background-color: #6b7280; }

        .sub-conditions-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .sub-condition-card h2 { font-size: 1.15em; } .sub-condition-card p.status-text { font-size: 0.95em; }

        #bitcoinAltcoinSentiment.indicator { background-color: rgba(0,0,0,0.05); color: white; }
        #bitcoinAltcoinSentiment.indicator.green { border-left-color: #a7f3d0; }
        #bitcoinAltcoinSentiment.indicator.yellow { border-left-color: #fef08a; }
        #bitcoinAltcoinSentiment.indicator strong { color: white; opacity: 0.9; }
        #bitcoinAltcoinSentiment.indicator span { color: white; opacity: 0.8; }

        .loading { opacity: 0.7; }
        .error { color: #b91c1c; font-size: 0.75em; display: block; margin-top: 2px; font-weight:500; }
        .api-key-note { font-size:0.65em; color:#a1a1aa; margin-top:7px; text-align: right;}

        .tradingview-container { margin-top: 15px; padding: 12px; background-color: #fff; border-radius: 8px; box-shadow: 0 3px 5px rgba(0,0,0,0.05); }
        .tradingview-container h2 { margin-top: 0; margin-bottom: 12px; font-size: 1.2em; color: #374151; }
        #tradingview-widget-placeholder { height: 550px; width: 100%;}
        #tradingview-widget-placeholder > .tradingview-widget-container__widget { height: 100% !important; width: 100% !important; }
    </style>
</head>
<body>

    <div class="dashboard-header">
        <h1>Geavanceerd Swingtrade Dashboard v2.7</h1>
        <p title="Alle data wordt periodiek ververst. Trends voor crypto dominantie/ratio's worden zichtbaar na de tweede data-ophaling.">
            Analyse van macro, sentiment & marktindicatoren. <span id="lastUpdated"></span>
        </p>
    </div>

    <div class="grid-container">
        <div class="card">
            <h2 title="Indicatoren die de algemene economische gezondheid en het beleid weerspiegelen.">Macro Omgeving</h2>
            <div id="m2Trend" class="indicator loading"><strong title="M2 Geldhoeveelheid: Brede maatstaf voor de geldhoeveelheid in een economie. Stijgend kan duiden op meer liquiditeit.">M2 Geldhoeveelheid Trend</strong><span>Laden...</span></div>
            <div id="interest10yrTrend" class="indicator loading"><strong title="10-Year Treasury Yield: Rente op Amerikaanse staatsobligaties met een looptijd van 10 jaar. Dalend is vaak positief voor activa.">Rente Trend (10jr Treasury)</strong><span>Laden...</span></div>
            <div id="interest2yrTrend" class="indicator loading"><strong title="2-Year Treasury Yield: Rente op Amerikaanse staatsobligaties met een looptijd van 2 jaar.">Rente Trend (2jr Treasury)</strong><span>Laden...</span></div>
            <div id="yieldCurve" class="indicator loading"><strong title="Yield Curve (10jr - 2jr): Verschil tussen 10-jaars en 2-jaars rente. Een inverse curve (negatief) kan een recessie voorspellen.">Yield Curve (10j - 2j)</strong><span>Laden...</span></div>
            <div id="fedStance" class="indicator loading"><strong title="Fed Beleid Stance: Interpretatie van het monetaire beleid van de Federal Reserve (Amerikaanse centrale bank), afgeleid van rentetrends.">Fed Beleid Stance</strong><span>Laden...</span></div>
            <div id="unemploymentTrend" class="indicator loading"><strong title="Werkloosheidspercentage: Percentage van de beroepsbevolking dat werkloos is. Dalend is positief.">Werkloosheid Trend</strong><span>Laden...</span></div>
            <div id="inflationTrend" class="indicator loading"><strong title="Consumer Price Index (CPI): Maatstaf voor inflatie. Dalende inflatie kan druk op de Fed verminderen.">Inflatie Trend (CPI Index)</strong><span>Laden...</span></div>
            <div id="ppiTrend" class="indicator loading"><strong title="Producenten Prijs Index (PPI): Voorlopende indicator voor consumenteninflatie. Stijgend is negatief.">PPI Trend</strong><span>Laden...</span></div>
            <div id="breakeven10yrTrend" class="indicator loading"><strong title="10-Year Breakeven Inflation Rate: Marktverwachting voor inflatie over de komende 10 jaar. Stijgend is negatief.">10jr Inflatieverwachting</strong><span>Laden...</span></div>
            <div id="retailSalesTrend" class="indicator loading"><strong title="Detailhandelsverkopen: Totale verkopen van detailhandelszaken. Stijgend duidt op sterke consumentenuitgaven.">Retail Sales Trend</strong><span>Laden...</span></div>
            <div id="ismPmiTrend" class="indicator loading"><strong title="ISM Manufacturing Purchasing Managers' Index: Index voor de productiesector. Boven 50 duidt op expansie.">ISM Manufacturing PMI</strong><span>Laden...</span></div>
            <div class="api-key-note">Macro data vereist FRED API Key.</div>
        </div>

        <div class="card">
            <h2 title="Indicatoren die de richting van kapitaalstromen en de status van globale activa weerspiegelen.">Geldstroom & Globale Indicatoren</h2>
            <div id="dxyTrend" class="indicator loading"><strong title="US Dollar Index (DXY): Waarde van de US dollar.">US Dollar Index (DXY) Trend</strong><span>Laden...</span></div>
            <div id="goldTrend" class="indicator loading"><strong title="Goudprijs via GLD ETF (proxy voor Goud XAU/USD)">Goud ETF (GLD) Trend</strong><span>Laden...</span></div>
            <div id="oilTrend" class="indicator loading"><strong title="Olieprijs via USO ETF (proxy voor WTI Crude)">Olie ETF (USO) Trend</strong><span>Laden...</span></div>
            <div id="copperTrend" class="indicator loading"><strong title="Koperprijs via CPER ETF: Barometer voor wereldwijde economische gezondheid. Stijgend is positief.">Koper ETF (CPER)</strong><span>Laden...</span></div>
            <div id="bondSpreadsTrend" class="indicator loading"><strong title="High Yield Corporate Bond Spreads: Verschil in rente tussen risicovolle bedrijfsobligaties en veilige staatsobligaties. Dalende spreads zijn positief.">High Yield Bond Spreads</strong><span>Laden...</span></div>
            <div class="api-key-note">Goud, Olie, Koper (ETF's): Finnhub/FMP API Key. Spreads: FRED API Key. DXY: FMP API Key.</div>
        </div>

        <div class="card">
            <h2 title="Metingen van het algemene gevoel of de psychologie van investeerders.">Markt Sentiment</h2>
            <div id="cryptoFearGreed" class="indicator loading"><strong title="Crypto Fear & Greed Index: Meet het sentiment in de cryptomarkt.">Crypto Fear & Greed Index</strong><span>Laden...</span></div>
            <div id="stockFearGreedVIX" class="indicator loading"><strong title="Volatility Index (VIX) als proxy voor Aandelen F&G">Aandelen F&G (VIX)</strong><span>Laden...</span></div>
            <div class="api-key-note">VIX: Finnhub API Key.</div>
        </div>

        <div class="card crypto-market-card">
            <h2 title="Indicatoren specifiek voor de interne dynamiek van de cryptomarkt.">Crypto Markt Intern</h2>
            <div id="btcPriceTrend" class="indicator loading"><strong title="Bitcoin (BTC) Prijs Trend">Bitcoin (BTC) Prijs Trend</strong><span>Laden...</span></div>
            <div id="ethPriceTrend" class="indicator loading"><strong title="Ethereum (ETH) Prijs Trend">Ethereum (ETH) Prijs Trend</strong><span>Laden...</span></div>
            <div id="btcDominanceTrend" class="indicator loading"><strong title="Bitcoin Dominantie (BTC.D)">Bitcoin Dominantie (BTC.D)</strong><span>Laden...</span></div>
            <div id="ethDominanceTrend" class="indicator loading"><strong title="Ethereum Dominantie (ETH.D)">Ethereum Dominantie (ETH.D)</strong><span>Laden...</span></div>
            <div id="altcoinMarketCapTrend" class="indicator loading"><strong title="Altcoin Market Cap (Ex-BTC)">Altcoin Market Cap (Ex-BTC)</strong><span>Laden...</span></div>
            <div id="ethBtcRatioTrend" class="indicator loading"><strong title="ETH/BTC Ratio Trend">ETH/BTC Ratio Trend</strong><span>Laden...</span></div>
            <div class="api-key-note">Trends voor dominanties/ratio zichtbaar na 2e refresh.</div>
        </div>

        <div class="card">
            <h2 title="Trends van belangrijke aandelenindices.">Traditionele Markten (Indices)</h2>
            <div id="sp500Trend" class="indicator loading"><strong title="S&P 500 Index (via SPY ETF)">S&P 500 Trend</strong><span>Laden...</span></div>
            <div id="nasdaq100Trend" class="indicator loading"><strong title="Nasdaq 100 Index (via QQQ ETF)">Nasdaq 100 Trend</strong><span>Laden...</span></div>
            <div id="russell2000Trend" class="indicator loading"><strong title="Russell 2000 Index (via IWM ETF): Small-cap aandelen. Stijgend is positief.">Russell 2000 (IWM ETF)</strong><span>Laden...</span></div>
            <div class="api-key-note">Indices (ETF's): Finnhub/FMP API Key.</div>
        </div>
    </div>

    <div id="generalMarketCondition" class="condition-card condition-neutral">
        <h2 title="Een gewogen samenvatting van alle belangrijke indicatoren om een algemeen beeld te vormen.">Algemene Marktconditie</h2>
        <p id="generalMarketText" class="status-text">Laden...</p>
        <div class="factors-title">Belangrijkste Factoren (Max. 3 Positief / 3 Negatief):</div>
        <ul id="generalMarketFactors" class="factors-list"><li>Laden...</li></ul>
    </div>
    <div class="sub-conditions-grid">
        <div id="cryptoMarketCondition" class="condition-card condition-neutral sub-condition-card">
            <h2 title="Specifieke analyse voor de cryptomarkt.">Crypto Marktconditie</h2>
            <p id="cryptoMarketText" class="status-text">Laden...</p>
            <div class="factors-title">Belangrijkste Crypto Factoren:</div>
            <ul id="cryptoMarketFactors" class="factors-list"><li>Laden...</li></ul>
            <div id="bitcoinAltcoinSentiment" class="indicator neutral" style="margin-top:12px; padding:7px;">
                <strong title="Geeft aan of het sentiment meer richting Bitcoin of altcoins neigt.">Bitcoin vs. Altcoin Sentiment</strong>
                <span>Laden...</span>
            </div>
        </div>
        <div id="stockMarketCondition" class="condition-card condition-neutral sub-condition-card">
            <h2 title="Specifieke analyse voor de aandelenmarkt.">Aandelen Marktconditie</h2>
            <p id="stockMarketText" class="status-text">Laden...</p>
            <div class="factors-title">Belangrijkste Aandelen Factoren:</div>
            <ul id="stockMarketFactors" class="factors-list"><li>Laden...</li></ul>
        </div>
    </div>

    <div class="tradingview-container">
        <h2>TradingView Grafiek</h2>
        <div id="tradingview-widget-placeholder">
            <!-- TradingView Widget BEGIN -->
            <div class="tradingview-widget-container" style="height:100%;width:100%">
              <div class="tradingview-widget-container__widget" style="height:calc(100% - 32px);width:100%"></div>
              <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/" rel="noopener nofollow" target="_blank"><span class="blue-text">Track all markets on TradingView</span></a></div>
              <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js" async>
              {
              "autosize": true,
              "symbol": "NASDAQ:AAPL",
              "interval": "D",
              "timezone": "Europe/Amsterdam",
              "theme": "light",
              "style": "1",
              "locale": "en",
              "allow_symbol_change": true,
              "watchlist": [
                "BINANCE:BTCUSDT",
                "BINANCE:SOLBTC",
                "BINANCE:ETHUSD",
                "BINANCE:ETHBTC",
                "COINBASE:SOLUSD",
                "SP:SPX",
                "MIL:VUAA",
                "CRYPTOCAP:OTHERS",
                "CRYPTOCAP:BTC.D"
              ],
              "hotlist": true,
              "studies": [
                "STD;RSI",
                "STD;Stochastic_RSI"
              ],
              "support_host": "https://www.tradingview.com"
            }
              </script>
            </div>
            <!-- TradingView Widget END -->
        </div>
    </div>

<script>
    // ---- API KEYS (ZEER BELANGRIJK: VUL DEZE IN!) ----
    console.log("Script gestart. API Keys initialiseren...");
    const FRED_API_KEY = '6eb928143eef77787366d5af41104d3e'; // Vervang '' met je FRED key
    const FINNHUB_API_KEY = 'd106impr01qhkqr86m9gd106impr01qhkqr86ma0'; // Vervang '' met je Finnhub key
    const FMP_API_KEY = 'Xpob3mGH7hEF2MT39Ev96ismedWfeXGT';   // Vervang '' met je FMP key

    console.log("FRED Key:", FRED_API_KEY ? "Ingevuld" : "LEEG!");
    console.log("Finnhub Key:", FINNHUB_API_KEY ? "Ingevuld" : "LEEG!");
    console.log("FMP Key:", FMP_API_KEY ? "Ingevuld" : "LEEG!");

    // ---- GLOBALE VARIABELEN VOOR TRENDS ----
    let previousBtcDom = null, previousEthDom = null, previousAltCap = null, previousEthBtcRatio = null;

    // ---- Helper Functies ----
    function setIndicator(elementId, title, detail, colorClass, error = null) {
        const element = document.getElementById(elementId);
        if (!element) { console.error("Element niet gevonden voor setIndicator:", elementId); return; }
        
        element.classList.remove('loading', 'green', 'yellow', 'red', 'neutral');
        if (colorClass) element.classList.add(colorClass);
        
        const strongElement = element.querySelector('strong') || document.createElement('strong');
        strongElement.textContent = title;
        // Behoud bestaande tooltip op strong als die er is, anders verwijder
        if(element.title && !strongElement.title) strongElement.title = element.title; 
        else if (!element.title && strongElement.title) strongElement.removeAttribute('title');


        const spanElement = element.querySelector('span:not(.error)') || document.createElement('span');
        spanElement.textContent = detail;
        
        element.innerHTML = ''; 
        element.appendChild(strongElement);
        element.appendChild(spanElement);
        
        const oldErrorSpan = element.querySelector('span.error');
        if (oldErrorSpan) oldErrorSpan.remove(); // Verwijder expliciet
        
        if (error) {
            const errorSpan = document.createElement('span');
            errorSpan.className = 'error'; 
            errorSpan.textContent = error; // Gebruik de error string direct
            element.appendChild(errorSpan);
        }
    }
    function formatDate(date) { return date.toLocaleString('nl-NL', { dateStyle: 'medium', timeStyle: 'short' }); }
    document.getElementById('lastUpdated').textContent = `Laatst bijgewerkt: ${formatDate(new Date())}`;

    const apiCache = new Map();
    const CACHE_DURATION = 5 * 60 * 1000; 
    async function fetchWithCache(url, options = {}, parser = 'json') {
        const now = Date.now();
        if (apiCache.has(url)) {
            const { timestamp, data } = apiCache.get(url);
            if (now - timestamp < CACHE_DURATION) { 
                console.log("Cache HIT for URL:", url.substring(0,120));
                return data; 
            }
        }
        console.log("Fetching URL (Cache MISS/EXPIRED):", url.substring(0,120));
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                let errorText = `Status: ${response.status}`;
                try { 
                    const errorBody = await response.text();
                    errorText = errorBody.length > 200 ? errorBody.substring(0,200) + "..." : errorBody;
                } catch (e) { console.warn("Kon error response body niet lezen:", e); }
                console.error(`API error! URL: ${url.substring(0,100)}. Status: ${response.status}. Response: ${errorText}`);
                throw new Error(`API Fout: ${response.status}`);
            }
            let responseData;
            if (parser === 'json') responseData = await response.json();
            else if (parser === 'text') responseData = await response.text();
            else responseData = response; 
            apiCache.set(url, { timestamp: now, data: responseData });
            return responseData;
        } catch (error) {
            console.error("fetchWithCache FAILED for ", url.substring(0,80), error);
            throw error; 
        }
    }

    function setMarketConditionCard(cardId, textId, factorsId, scorePercentage, conditionText, positiveFactors, negativeFactors, numSignals) {
        const cardElement = document.getElementById(cardId);
        const textElement = document.getElementById(textId);
        const factorsElement = document.getElementById(factorsId);
        if (!cardElement || !textElement || !factorsElement) { console.error("Conditiekaart element niet gevonden:", cardId); return; }
        cardElement.classList.remove('very-positive', 'positive', 'negative', 'very-negative', 'condition-neutral', 'loading');
        if (conditionText.toLowerCase().includes("onvoldoende data") || conditionText.toLowerCase().includes("api key")) { cardElement.classList.add('condition-neutral'); }
        else if (scorePercentage > 55) cardElement.classList.add('very-positive'); else if (scorePercentage > 15) cardElement.classList.add('positive');
        else if (scorePercentage < -55) cardElement.classList.add('very-negative'); else if (scorePercentage < -15) cardElement.classList.add('negative');
        else cardElement.classList.add('condition-neutral');
        textElement.textContent = conditionText;
        textElement.title = `Score: ${scorePercentage.toFixed(0)}% (${numSignals} signalen)`;
        let factorsHTML = '';
        positiveFactors.slice(0, 3).forEach(factor => factorsHTML += `<li class="factor-positive" title="${factor.name}: ${factor.detailFull || factor.detail}">${factor.name}: ${factor.detail}</li>`);
        negativeFactors.slice(0, 3).forEach(factor => factorsHTML += `<li class="factor-negative" title="${factor.name}: ${factor.detailFull || factor.detail}">${factor.name}: ${factor.detail}</li>`);
        const totalFactors = positiveFactors.length + negativeFactors.length;
        const anyKeyMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === '' || FMP_API_KEY === '';
        if (numSignals === 0 && anyKeyMissing) { factorsHTML = '<li title="Zonder API keys kan geen volledige analyse worden gemaakt.">API Key(s) niet geconfigureerd.</li>'; }
        else if (numSignals < 3 && !anyKeyMissing) { factorsHTML = `<li title="Er zijn te weinig datapunten beschikbaar voor een betrouwbare lijst van factoren.">Onvoldoende data (${numSignals} signaal/en).</li>`; }
        else if (totalFactors === 0 && numSignals > 0) { factorsHTML = `<li title="De meeste indicatoren geven een neutraal beeld, of heffen elkaar op.">Geen sterk positieve/negatieve factoren.</li>`; }
        else if (factorsHTML === '') { factorsHTML = '<li title="Wacht tot alle data is geladen, of controleer de API keys.">Analyse data wordt geladen...</li>'; }
        factorsElement.innerHTML = factorsHTML;
    }

    // ---- Data Ophalingsfuncties ----
    async function fetchFredSeries(seriesId, elementName, title, positiveChangeIsGood = true, unit = "%", valueMultiplier = 1, higherIsBetterThreshold = null) {
        const defaultReturn = { value: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood, change: null };
        if (FRED_API_KEY === '' || !FRED_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel FRED API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'FRED API Key niet geconfigureerd.' };
        }
        
        // Originele FRED URL
        const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=2&sort_order=desc`;
        
        // URL voor de CORS proxy
        // encodeURIComponent zorgt ervoor dat de fredUrl correct wordt meegegeven als query parameter aan de proxy
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(fredUrl)}`;
        
        console.log("Fetching FRED via Proxy:", proxyUrl); // Log de URL die we daadwerkelijk fetchen

        try {
            // Gebruik de proxyUrl voor de fetch call
            const data = await fetchWithCache(proxyUrl); 
            // Omdat allorigins.win/raw?url= de response body direct doorgeeft als JSON,
            // en FRED direct JSON teruggeeft, zou de 'data' variabele hier de geparste JSON van FRED moeten zijn.

            const observations = data.observations;
            if (observations && observations.length > 0) {
                const latestObs = observations[0];
                if (latestObs.value === "." || isNaN(parseFloat(latestObs.value))) {
                     setIndicator(elementName, title, 'Data ongeldig (FRED)', 'neutral', 'Ongeldige waarde');
                     return { ...defaultReturn, detail: 'Ongeldige data (FRED)', detailFull: 'Recente data van FRED is ongeldig.' };
                }
                const latestValue = parseFloat(latestObs.value) * valueMultiplier;
                let previousValue = null; let change = null;
                let trendText = `${latestValue.toFixed(2)}${unit}`; let colorClass = 'yellow';
                let trendDescription = "Stabiel";
                if (observations.length >= 2 && observations[1].value !== "." && !isNaN(parseFloat(observations[1].value))) {
                    previousValue = parseFloat(observations[1].value) * valueMultiplier; change = latestValue - previousValue;
                    const relChangeThreshold = 0.0005; 
                    if (change > Math.abs(previousValue * relChangeThreshold) || (previousValue === 0 && change > 0.0001 * valueMultiplier)) { 
                        colorClass = positiveChangeIsGood ? 'green' : 'red'; trendDescription = "Stijgend";
                    } else if (change < -Math.abs(previousValue * relChangeThreshold) || (previousValue === 0 && change < -0.0001 * valueMultiplier)) { 
                        colorClass = positiveChangeIsGood ? 'red' : 'green'; trendDescription = "Dalend";
                    }
                }
                if (higherIsBetterThreshold !== null) {
                    const thresholdOffset = unit === "%" ? 0.2 : 1.5;
                    if (latestValue > higherIsBetterThreshold + thresholdOffset ) { 
                         colorClass = 'green'; trendDescription = latestValue > higherIsBetterThreshold ? `Boven ${higherIsBetterThreshold}` : trendDescription;
                    } else if (latestValue < higherIsBetterThreshold - thresholdOffset ) {
                         colorClass = 'red'; trendDescription = latestValue < higherIsBetterThreshold ? `Onder ${higherIsBetterThreshold}` : trendDescription;
                    } else { 
                         colorClass = 'yellow'; trendDescription = `Rond ${higherIsBetterThreshold}`;
                    }
                }
                let fullDetailText = `${trendText} (${trendDescription})`;
                setIndicator(elementName, title, fullDetailText, colorClass);
                return { value: latestValue, colorClass, name: title, detail: trendText.split('(')[0].trim(), detailFull: fullDetailText, positiveChangeIsGood, change };
            } else { 
                setIndicator(elementName, title, 'Geen data (FRED)', 'neutral', 'Geen observaties van FRED.'); 
                return { ...defaultReturn, detail: 'Geen data (FRED)', detailFull:'Geen observaties van FRED. Mogelijk 404 via proxy.' };
            }
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch (FRED via Proxy)";
            if (error.message && error.message.includes("404")) { // Specifieke check voor 404
                errMsg = "FRED API 404 (Proxy): Resource niet gevonden.";
            }
            console.error("Error in fetchFredSeries (via Proxy):", error);
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }
    
    async function fetchFmpQuote(symbol, elementName, title, positiveChangeIsGood = true, isIndexType = true) {
        const defaultReturn = { value: null, changePercent: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood };
        if (FMP_API_KEY === '' || !FMP_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel FMP API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'FMP API Key niet geconfigureerd.' };
        }
        const url = `https://financialmodelingprep.com/api/v3/quote/${symbol}?apikey=${FMP_API_KEY}`;
        try {
            const data = await fetchWithCache(url); 
            if (data && data.length > 0 && data[0].changesPercentage !== undefined && data[0].price !== undefined) {
                const quote = data[0];
                const price = parseFloat(quote.price);
                const changePercent = parseFloat(quote.changesPercentage);

                if (isNaN(price) || isNaN(changePercent)) {
                    setIndicator(elementName, title, 'Ongeldige data (FMP)', 'neutral', 'Ongeldige waarde FMP');
                    return { ...defaultReturn, detail: 'Ongeldige data (FMP)', detailFull: 'Ongeldige data van FMP.' };
                }
                let colorClass;
                const threshold = isIndexType ? 0.10 : 0.30; 
                if (changePercent > threshold) { colorClass = positiveChangeIsGood ? 'green' : 'red'; }
                else if (changePercent < -threshold) { colorClass = positiveChangeIsGood ? 'red' : 'green'; }
                else { colorClass = 'yellow'; }
                let fullDetailText = `${price.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                setIndicator(elementName, title, fullDetailText, colorClass);
                return { value: price, changePercent, colorClass, name: title, detail: price.toFixed(2), detailFull: fullDetailText, positiveChangeIsGood };
            } else if (data && data.length > 0 && data[0]["Error Message"]) { 
                let errMsg = data[0]["Error Message"];
                 if(errMsg.toLowerCase().includes("limit exceeded") || errMsg.toLowerCase().includes("invalid api key")) errMsg = "FMP API Limiet/Key Probleem";
                setIndicator(elementName, title, `FMP: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `FMP Error`, detailFull: `FMP API error: ${errMsg}` };
            } else if (data && data["Error Message"]) { 
                let errMsg = data["Error Message"];
                if(errMsg.toLowerCase().includes("limit exceeded") || errMsg.toLowerCase().includes("invalid api key")) errMsg = "FMP API Limiet/Key Probleem";
                setIndicator(elementName, title, `FMP: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `FMP Error`, detailFull: `FMP API error: ${errMsg}` };
            }
             else {
                let noDataMsg = 'Geen data (FMP)';
                if (data && data.length === 0) noDataMsg = 'Lege response (FMP)';
                setIndicator(elementName, title, noDataMsg, 'neutral', 'Mogelijk ongeldig symbool of API probleem.');
                return { ...defaultReturn, detail: noDataMsg, detailFull: `${noDataMsg} (mogelijk ongeldig symbool, API key probleem of geen data voor symbool van FMP).` };
            }
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
             if (error.message && (error.message.includes("API Fout: 401") || error.message.includes("API Fout: 403"))){ errMsg = "FMP API Key ongeldig/geblokkeerd"; }
             else if (error.message && error.message.includes("API Fout: 429")){ errMsg = "FMP API Limiet bereikt"; }
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchFinnhubQuote(symbol, elementName, title, positiveChangeIsGood = true, isIndexType = true) {
        const defaultReturn = { value: null, changePercent: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood };
        if (FINNHUB_API_KEY === '' || !FINNHUB_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel Finnhub API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'Finnhub API Key niet geconfigureerd.' };
        }
        const url = `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`;
        try {
            const data = await fetchWithCache(url);
            if (data && data.c !== undefined && data.dp !== undefined && data.t !== 0) { // Check data.t !== 0 to avoid stale data
                const price = parseFloat(data.c); const changePercent = parseFloat(data.dp);
                if (isNaN(price) || isNaN(changePercent)) {
                    setIndicator(elementName, title, 'Ongeldige data (FH)', 'neutral', 'Ongeldige waarde FH');
                    return { ...defaultReturn, detail: 'Ongeldige data', detailFull: 'Ongeldige data van Finnhub.' };
                }
                let colorClass; const threshold = isIndexType ? 0.15 : 0.4; 
                if (changePercent > threshold) { colorClass = positiveChangeIsGood ? 'green' : 'red'; }
                else if (changePercent < -threshold) { colorClass = positiveChangeIsGood ? 'red' : 'green'; }
                else { colorClass = 'yellow'; }
                let fullDetailText = `${price.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                setIndicator(elementName, title, fullDetailText, colorClass);
                return { value: price, changePercent, colorClass, name: title, detail: price.toFixed(2), detailFull: fullDetailText, positiveChangeIsGood };
            } else if (data && data.error) {
                 let errMsg = data.error;
                 if(errMsg.toLowerCase().includes("invalid api key") || errMsg.toLowerCase().includes("please subscribe to get us stock data")) errMsg = "Finnhub API Key/Abo Probleem";
                setIndicator(elementName, title, `Finnhub: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `Finnhub Error`, detailFull: `Finnhub API error: ${errMsg}` };
            } else if (data && (data.c === 0 || data.t === 0)){ 
                setIndicator(elementName, title, 'Geen data (Finnhub Nul/Stale)', 'neutral', 'Finnhub retourneerde nullen of oude data. Mogelijk onbekend/vertraagd symbool.');
                return { ...defaultReturn, detail: 'Geen data (FH Nul/Stale)', detailFull: 'Finnhub retourneerde nullen of oude data. Mogelijk onbekend/vertraagd symbool.' };
            }
            else {
                setIndicator(elementName, title, 'Geen data (Finnhub)', 'neutral', 'Mogelijk ongeldig symbool of API probleem.');
                return { ...defaultReturn, detail: 'Geen data (FH)', detailFull: 'Geen data van Finnhub (mogelijk ongeldig symbool of API probleem).' };
            }
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
             if (error.message && (error.message.includes("API Fout: 401") || error.message.includes("API Fout: 403"))){ errMsg = "Finnhub API Key ongeldig/geblokkeerd"; }
             else if (error.message && error.message.includes("API Fout: 429")){ errMsg = "Finnhub API Limiet bereikt"; }
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchCryptoFearGreed() {
        const title = "Crypto F&G"; const elementName = 'cryptoFearGreed';
        const defaultReturn = { value: null, classification: 'Laden...', colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        const url = 'https://api.alternative.me/fng/?limit=1&format=json';
        try {
            const data = await fetchWithCache(url);
            const value = parseInt(data.data[0].value); const classification = data.data[0].value_classification;
            let colorClass; let detailText = `${value} - ${classification}`; let isBullish = false, isBearish = false;
            if (value <= 25) { colorClass = 'green'; detailText = `${value} (Extr. Angst)`; isBullish = true; } 
            else if (value <= 45) { colorClass = 'yellow'; detailText = `${value} (Angst)`; }
            else if (value <= 55) { colorClass = 'neutral'; detailText = `${value} (Neutraal)`; }
            else if (value <= 75) { colorClass = 'yellow'; detailText = `${value} (Hebzucht)`; } 
            else { colorClass = 'red'; detailText = `${value} (Extr. Hebzucht)`; isBearish = true; } 
            setIndicator(elementName, title, detailText, colorClass);
            return { value, classification, colorClass, name: title, detail: classification, detailFull: detailText, isBullish, isBearish };
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg); return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchCryptoPrice(coinId, elementName, title) {
        const defaultReturn = { value: null, change24h: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        const url = `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true`;
        try {
            const data = await fetchWithCache(url);
            if (!data || !data[coinId] || data[coinId].usd === undefined || data[coinId].usd_24h_change === undefined) {
                 setIndicator(elementName, title, 'Prijsdata ongeldig (CG)', 'neutral', 'Ongeldige waarde CG'); return {...defaultReturn, detail:'Ongeldige data (CG)', detailFull:'Ongeldige prijsdata van CoinGecko.'};
            }
            const price = data[coinId].usd; const change24h = data[coinId].usd_24h_change;
            let trendStatus, colorClass; let isBullish = false, isBearish = false;
            if (change24h > 1.5) { trendStatus = `Opwaarts`; colorClass = 'green'; isBullish = true;}
            else if (change24h < -1.5) { trendStatus = `Dalend`; colorClass = 'red'; isBearish = true;}
            else { trendStatus = `Zijwaarts`; colorClass = 'yellow'; }
            let fullDetailText = `${trendStatus} (${price.toFixed(price < 1 ? 4 : 2)} USD, ${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}% 24u)`;
            setIndicator(elementName, title, fullDetailText, colorClass);
            return { value: price, change24h, colorClass, name: title, detail: trendStatus, detailFull: fullDetailText, isBullish, isBearish };
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg); return {...defaultReturn, detail:'Data Error', detailFull: errMsg};
        }
    }

    async function fetchCoinGeckoGlobalData() {
        const defaultReturn = { btcDominanceTrend: null, ethDominanceTrend: null, altcoinMarketCapTrend: null };
        const url = 'https://api.coingecko.com/api/v3/global';
        try {
            const data = await fetchWithCache(url); const globalData = data.data; let results = {}; let trendStatus;

            const btcD = globalData.market_cap_percentage.btc; let btcDc = 'yellow', btcDt = `${btcD.toFixed(1)}% (Initieel)`; let btcDisB = false, btcDisBe = false;
            if (previousBtcDom !== null) { 
                if (btcD < previousBtcDom - 0.15) { btcDc = 'green'; trendStatus = "Dalend"; btcDisB = true;} 
                else if (btcD > previousBtcDom + 0.15) { btcDc = 'red'; trendStatus = "Stijgend"; btcDisBe = true;}
                else { trendStatus = "Stabiel";} btcDt = `${btcD.toFixed(1)}% (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('btcDominanceTrend', 'BTC Dominantie', btcDt, btcDc);
            results.btcDominanceTrend = { value: btcD, colorClass: btcDc, name: 'BTC Dominantie', detail: `${btcD.toFixed(1)}%`, detailFull: btcDt, isBullish: btcDisB, isBearish: btcDisBe };
            if (previousBtcDom === null && btcD !== undefined) previousBtcDom = btcD;

            const ethD = globalData.market_cap_percentage.eth; let ethDc = 'yellow', ethDt = `${ethD.toFixed(1)}% (Initieel)`; let ethDisB = false, ethDisBe = false;
            if (previousEthDom !== null) { 
                if (ethD > previousEthDom + 0.1) { ethDc = 'green'; trendStatus = "Stijgend"; ethDisB = true;}
                else if (ethD < previousEthDom - 0.1) { ethDc = 'red'; trendStatus = "Dalend"; ethDisBe = true;}
                else { trendStatus = "Stabiel";} ethDt = `${ethD.toFixed(1)}% (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('ethDominanceTrend', 'ETH Dominantie', ethDt, ethDc);
            results.ethDominanceTrend = { value: ethD, colorClass: ethDc, name: 'ETH Dominantie', detail: `${ethD.toFixed(1)}%`, detailFull: ethDt, isBullish: ethDisB, isBearish: ethDisBe };
            if (previousEthDom === null && ethD !== undefined) previousEthDom = ethD;

            const totalMC = globalData.total_market_cap.usd; const btcMC = btcD / 100 * totalMC; const altMC = totalMC - btcMC;
            const altMCf = (altMC / 1e9).toFixed(0); let altMCc = 'yellow', altMCt = `$${altMCf}B (Initieel)`; let altDisB = false, altDisBe = false;
            if (previousAltCap !== null) { 
                if (altMC > previousAltCap * 1.015) { altMCc = 'green'; trendStatus = "Stijgend"; altDisB = true;}
                else if (altMC < previousAltCap * 0.985) { altMCc = 'red'; trendStatus = "Dalend"; altDisBe = true;}
                else { trendStatus = "Stabiel";} altMCt = `$${altMCf}B (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('altcoinMarketCapTrend', 'Altcoin MarketCap (Ex-BTC)', altMCt, altMCc);
            results.altcoinMarketCapTrend = { value: altMC, colorClass: altMCc, name: 'Altcoin MC', detail: `$${altMCf}B`, detailFull: altMCt, isBullish: altDisB, isBearish: altDisBe };
            if (previousAltCap === null && altMC !== undefined) previousAltCap = altMC;

            return results;
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch CG Global";
            console.error('Error CoinGecko Global:', errMsg);
            setIndicator('btcDominanceTrend', 'BTC Dominantie', 'Data Error', 'neutral', errMsg);
            setIndicator('ethDominanceTrend', 'ETH Dominantie', 'Data Error', 'neutral', errMsg);
            setIndicator('altcoinMarketCapTrend', 'Altcoin MarketCap (Ex-BTC)', 'Data Error', 'neutral', errMsg);
            return defaultReturn;
        }
    }

    async function calculateEthBtcRatio(btcData, ethData) {
        const title = "ETH/BTC Ratio"; const elementName = 'ethBtcRatioTrend';
        const defaultReturn = { value: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        if (btcData && btcData.value && ethData && ethData.value) {
            const ratio = ethData.value / btcData.value; let trendText = `${ratio.toFixed(5)} (Initieel)`, colorClass = 'yellow';
            let isBullish = false, isBearish = false; let trendStatus = "Initieel";
            if (previousEthBtcRatio !== null) { 
                if (ratio > previousEthBtcRatio * 1.0075) { trendStatus = "Stijgend"; colorClass = 'green'; isBullish = true;}
                else if (ratio < previousEthBtcRatio * 0.9925) { trendStatus = "Dalend"; colorClass = 'red'; isBearish = true;}
                else { trendStatus = "Stabiel";}
                trendText = `${ratio.toFixed(5)} (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator(elementName, title, trendText, colorClass);
            if (previousEthBtcRatio === null && ratio !== undefined) previousEthBtcRatio = ratio;
            return { value: ratio, colorClass, name: title, detail: ratio.toFixed(5), detailFull: trendText, isBullish, isBearish };
        } else { 
            setIndicator(elementName, title, 'Prijsdata BTC/ETH mist', 'neutral', 'BTC/ETH prijsdata niet beschikbaar'); 
            return defaultReturn;
        }
    }

    function analyzeAndScore(results, relevantKeysAndWeights) {
        let score = 0; let totalWeightApplied = 0;
        let positiveFactors = []; let negativeFactors = []; let numValidSignals = 0;
        for (const key in relevantKeysAndWeights) {
            const indicator = results[key]; 
            const baseWeight = relevantKeysAndWeights[key]; 

            if (indicator && indicator.colorClass && indicator.colorClass !== 'neutral' && indicator.detail &&
                !indicator.detail.toLowerCase().includes('api key') && !indicator.detail.toLowerCase().includes('data mist') &&
                !indicator.detail.toLowerCase().includes('ongeldig') && !indicator.detail.toLowerCase().includes('laden') && 
                !indicator.detail.toLowerCase().includes('error') && 
                (indicator.value !== null || indicator.changePercent !== null || indicator.change !== null ) ) {
                numValidSignals++; 
                let currentScoreContribution = 0;
                let factorName = indicator.name || key;
                let factorDetailShort = indicator.detail.split('(')[0].trim() || indicator.value?.toFixed(2) || indicator.detail;
                let factorDetailForTooltip = indicator.detailFull || indicator.detail;
                
                if (indicator.colorClass === 'green') { 
                    currentScoreContribution = baseWeight; 
                } else if (indicator.colorClass === 'red') { 
                    currentScoreContribution = -baseWeight; 
                }
                
                score += currentScoreContribution; 
                totalWeightApplied += baseWeight; 
                
                if (currentScoreContribution > 0) { 
                    positiveFactors.push({ name: factorName, detail: factorDetailShort, detailFull: factorDetailForTooltip }); 
                } else if (currentScoreContribution < 0) { 
                    negativeFactors.push({ name: factorName, detail: factorDetailShort, detailFull: factorDetailForTooltip }); 
                }
            }
        }
        const percentageScore = totalWeightApplied > 0 ? (score / totalWeightApplied) * 100 : 0;
        return { percentageScore, positiveFactors, negativeFactors, numSignals: numValidSignals };
    }

    function updateGeneralMarketCondition(results) {
        const weights = {
            m2Trend: 1, interest10yrTrend: 1.5, yieldCurve: 2, unemploymentTrend: 1, 
            inflationTrend: 1.2, ppiTrend: 1.0, breakeven10yrTrend: 1.0,
            retailSalesTrend: 1, ismPmiTrend: 1.5, 
            dxyTrend: 1.2, goldTrend: 0.5, oilTrend: 0.7, copperTrend: 0.8,
            bondSpreadsTrend: 1.5, 
            cryptoFearGreed: 0.6, stockFearGreedVIX: 1.0, 
            sp500Trend: 1, nasdaq100Trend: 1, russell2000Trend: 0.8,
            btcPriceTrend: 0.5, ethPriceTrend: 0.5 
        };
        const analysis = analyzeAndScore(results, weights); let conditionText = "Neutraal / Gemengd";
        const minSignalsForFullAnalysis = 10; 
        const anyKeyMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === '' || FMP_API_KEY === '';
        if (analysis.numSignals < minSignalsForFullAnalysis && anyKeyMissing ) { conditionText = "API Key(s) Mist voor Volledige Analyse"; }
        else if (analysis.numSignals < 5) { conditionText = "Onvoldoende Data voor Analyse"; } 
        else if (analysis.percentageScore > 55) conditionText = "Zeer Positief"; else if (analysis.percentageScore > 15) conditionText = "Positief";
        else if (analysis.percentageScore < -55) conditionText = "Zeer Negatief"; else if (analysis.percentageScore < -15) conditionText = "Negatief";
        setMarketConditionCard('generalMarketCondition', 'generalMarketText', 'generalMarketFactors', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals);
    }

    function updateCryptoMarketCondition(results) {
        const cryptoWeights = {
            cryptoFearGreed: 1.5, btcPriceTrend: 1.2, ethPriceTrend: 1.2,
            altcoinMarketCapTrend: 1
        };
        const analysis = analyzeAndScore(results, cryptoWeights); let conditionText = "Crypto Neutraal";
        if (analysis.numSignals < 3) { conditionText = "Crypto Onvoldoende Data"; } 
        else if (analysis.percentageScore > 55) conditionText = "Crypto Zeer Bullish"; else if (analysis.percentageScore > 15) conditionText = "Crypto Bullish";
        else if (analysis.percentageScore < -55) conditionText = "Crypto Zeer Bearish"; else if (analysis.percentageScore < -15) conditionText = "Crypto Bearish";
        setMarketConditionCard('cryptoMarketCondition', 'cryptoMarketText', 'cryptoMarketFactors', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals);
        
        let btcAltScore = 0; let btcAltDetailParts = [];
        if (results.btcDominanceTrend && results.btcDominanceTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("BTC.Dâ†“");}
        else if (results.btcDominanceTrend && results.btcDominanceTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("BTC.Dâ†‘");}

        if (results.altcoinMarketCapTrend && results.altcoinMarketCapTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("AltMCâ†‘");}
        else if (results.altcoinMarketCapTrend && results.altcoinMarketCapTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("AltMCâ†“");}

        if (results.ethBtcRatioTrend && results.ethBtcRatioTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("ETH/BTCâ†‘");}
        else if (results.ethBtcRatioTrend && results.ethBtcRatioTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("ETH/BTCâ†“");}
        
        let btcAltText = "Neutraal"; let btcAltColor = "yellow";
        const allApisConfigured = FRED_API_KEY && FINNHUB_API_KEY && FMP_API_KEY;
        if (btcAltDetailParts.length < 2 && allApisConfigured) { 
            btcAltText = "Onvoldoende Data"; btcAltColor = "neutral";
        } else if (btcAltDetailParts.length < 1 && !allApisConfigured) {
             btcAltText = "API Keys?"; btcAltColor = "neutral";
        } else if (btcAltDetailParts.length < 1 && allApisConfigured) { // Nog geen data voor trends
             btcAltText = "Initieel..."; btcAltColor = "neutral"; 
        }
        else if (btcAltScore >= 2) { btcAltText = "Altcoin Gunstig"; btcAltColor = "green"; }
        else if (btcAltScore <= -1) { btcAltText = "Bitcoin Gunstiger"; btcAltColor = "red"; } 
        
        const detailString = btcAltDetailParts.length > 0 ? `(${btcAltDetailParts.slice(0,3).join(', ')})` : (allApisConfigured ? "(Wacht op trends)" : "");
        setIndicator('bitcoinAltcoinSentiment', 'Bitcoin vs. Altcoin Sentiment', `${btcAltText} ${detailString}`, btcAltColor);
    }

    function updateStockMarketCondition(results) {
        const weights = {
            sp500Trend: 1.2, nasdaq100Trend: 1.2, russell2000Trend: 1.0,
            stockFearGreedVIX: 1.5, yieldCurve: 1.5, 
            ismPmiTrend: 1.2, bondSpreadsTrend: 1, interest10yrTrend: 1, retailSalesTrend: 0.8, 
            unemploymentTrend: 0.5, ppiTrend: 0.7, breakeven10yrTrend: 0.7, copperTrend: 0.6
        };
        const analysis = analyzeAndScore(results, weights); let conditionText = "Aandelen Neutraal";
        const minSignalsForStocks = 6; 
        const relevantKeysMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === ''; // FMP is mainly DXY
         if (analysis.numSignals < minSignalsForStocks && relevantKeysMissing ) { conditionText = "API Key(s) Mist voor Analyse"; }
        else if (analysis.numSignals < 4) { conditionText = "Aandelen Onvoldoende Data"; } 
        else if (analysis.percentageScore > 55) conditionText = "Aandelen Zeer Bullish"; else if (analysis.percentageScore > 15) conditionText = "Aandelen Bullish";
        else if (analysis.percentageScore < -55) conditionText = "Aandelen Zeer Bearish"; else if (analysis.percentageScore < -15) conditionText = "Aandelen Bearish";
        setMarketConditionCard('stockMarketCondition', 'stockMarketText', 'stockMarketFactors', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals);
    }

    async function loadDashboardData() {
        console.log("loadDashboardData gestart...");
        document.getElementById('lastUpdated').textContent = `Laden... ${formatDate(new Date())}`;
        let results = {};

        const initialPromises = [
            fetchFredSeries('M2SL', 'm2Trend', 'M2 Geldhoeveelheid', true, " T USD", 1/1000).then(r => results.m2Trend = r),
            fetchFredSeries('DGS10', 'interest10yrTrend', '10jr Rente', false, "%").then(r => results.interest10yrTrend = r), 
            fetchFredSeries('DGS2', 'interest2yrTrend', '2jr Rente', false, "%").then(r => results.interest2yrTrend = r),       
            fetchFredSeries('UNRATE', 'unemploymentTrend', 'Werkloosheid', false, "%").then(r => results.unemploymentTrend = r), 
            fetchFredSeries('CPIAUCSL', 'inflationTrend', 'Inflatie (CPI Index)', false, " (Index)").then(r => results.inflationTrend = r), 
            fetchFredSeries('PPIACO', 'ppiTrend', 'PPI Trend', false, " (Index)").then(r => results.ppiTrend = r),
            fetchFredSeries('T10YIE', 'breakeven10yrTrend', '10jr Inflatieverwachting', false, "%").then(r => results.breakeven10yrTrend = r),
            fetchFredSeries('RRSFS', 'retailSalesTrend', 'Retail Sales', true, " B USD", 1/1000).then(r => results.retailSalesTrend = r),
            fetchFredSeries('PMI', 'ismPmiTrend', 'ISM PMI', true, "", 1, 50).then(r => results.ismPmiTrend = r), 
            
            fetchFmpQuote('DX-Y.NYB', 'dxyTrend', 'US Dollar Index (DXY)', false, true).then(r => results.dxyTrend = r),
            fetchFinnhubQuote('GLD', 'goldTrend', 'Goud ETF (GLD)', true, false).then(r => results.goldTrend = r), 
            fetchFinnhubQuote('USO', 'oilTrend', 'Olie ETF (USO)', false, false).then(r => results.oilTrend = r),
            fetchFinnhubQuote('CPER', 'copperTrend', 'Koper ETF (CPER)', true, false).then(r => results.copperTrend = r), 
            fetchFredSeries('BAMLH0A0HYM2', 'bondSpreadsTrend', 'HY Bond Spreads', false, "%").then(r => results.bondSpreadsTrend = r), 
            
            fetchCryptoFearGreed().then(r => results.cryptoFearGreed = r), 
            fetchFinnhubQuote('^VIX', 'stockFearGreedVIX', 'Aandelen F&G (VIX)', false, false).then(r => results.stockFearGreedVIX = r), 
            
            fetchCryptoPrice('bitcoin', 'btcPriceTrend', 'Bitcoin Prijs').then(r => results.btcPriceTrend = r),
            fetchCryptoPrice('ethereum', 'ethPriceTrend', 'Ethereum Prijs').then(r => results.ethPriceTrend = r),
            
            fetchFinnhubQuote('SPY', 'sp500Trend', 'S&P 500 (SPY ETF)', true, true).then(r => results.sp500Trend = r),
            fetchFinnhubQuote('QQQ', 'nasdaq100Trend', 'Nasdaq 100 (QQQ ETF)', true, true).then(r => results.nasdaq100Trend = r),
            fetchFinnhubQuote('IWM', 'russell2000Trend', 'Russell 2000 (IWM ETF)', true, true).then(r => results.russell2000Trend = r)
        ];

        console.log("Wachten op Promise.allSettled...", initialPromises.length, "promises");
        const allSettledResults = await Promise.allSettled(initialPromises);
        console.log("Promise.allSettled voltooid.");

        allSettledResults.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Promise op index ${index} (data-ophaling) is mislukt:`, result.reason);
            }
        });

        console.log("Verwerken van afgeleide indicatoren (Yield Curve, Fed Stance)...");
        if (results.interest10yrTrend && results.interest10yrTrend.value !== null && results.interest10yrTrend.colorClass !== 'neutral' &&
            results.interest2yrTrend && results.interest2yrTrend.value !== null && results.interest2yrTrend.colorClass !== 'neutral') {
            const i10yr = results.interest10yrTrend; const i2yr = results.interest2yrTrend;
            const yieldSpread = i10yr.value - i2yr.value;
            let prevYieldSpread = null;
            if (i10yr.change !== null && i2yr.change !== null && i10yr.value !== null && i2yr.value !== null) {
                 const prev10yr = i10yr.value - i10yr.change;
                 const prev2yr = i2yr.value - i2yr.change;
                 prevYieldSpread = prev10yr - prev2yr;
            }
            let ycColor = 'yellow', ycTrend = "Stabiel";
            if (yieldSpread < 0) { ycColor = 'red'; ycTrend = "INVERS!";} 
            else if (yieldSpread < 0.20) { ycColor = 'yellow'; ycTrend = "Vlak";} 
            else if (prevYieldSpread !== null && yieldSpread > prevYieldSpread + 0.03) { ycColor = 'green'; ycTrend = "Versteilend";} 
            else if (prevYieldSpread !== null && yieldSpread < prevYieldSpread - 0.03) { ycColor = 'yellow'; ycTrend = "Afvlakkend";} 
            else if (yieldSpread >= 0.20) { ycColor = 'green'; ycTrend = "Normaal";} 
            let ycText = `${yieldSpread.toFixed(2)}% (${ycTrend})`;
            setIndicator('yieldCurve', 'Yield Curve (10j - 2j)', ycText, ycColor);
            results.yieldCurve = { value: yieldSpread, colorClass: ycColor, name: "Yield Curve", detail: `${yieldSpread.toFixed(2)}%`, detailFull: ycText, positiveChangeIsGood: (ycColor==='green') };
        } else {
            let errorMsg = "10j/2j data incompleet";
            if (!FRED_API_KEY) errorMsg = "Koppel FRED API Key";
            setIndicator('yieldCurve', 'Yield Curve', 'Rentedata mist', 'neutral', errorMsg);
            results.yieldCurve = {value:null, colorClass:'neutral', name:"Yield Curve", detail:"Rentedata mist", detailFull:"Rentedata 10j/2j mist voor Yield Curve berekening."};
        }

        if (results.interest10yrTrend && results.interest10yrTrend.colorClass && results.interest10yrTrend.colorClass !== 'neutral' && results.interest10yrTrend.detailFull) {
            let fedColor = results.interest10yrTrend.colorClass; 
            let fedText = "Neutraal";
            const detailFullLower = results.interest10yrTrend.detailFull.toLowerCase();
            if (detailFullLower.includes("stijgend")) { 
                fedText = "Verkrappend (Hawkish)"; fedColor = 'red'; 
            } else if (detailFullLower.includes("dalend")) { 
                fedText = "Verruimend (Dovish)"; fedColor = 'green'; 
            } else { fedColor = 'yellow'; }
            setIndicator('fedStance', 'Fed Beleid Stance', fedText, fedColor);
            results.fedStance = { value: null, colorClass: fedColor, name: "Fed Beleid", detail: fedText, detailFull: fedText, positiveChangeIsGood: (fedColor==='green') };
        } else {
            let errorMsg = "10j data incompleet";
            if (!FRED_API_KEY) errorMsg = "Koppel FRED API Key";
            setIndicator('fedStance', 'Fed Beleid Stance', 'Rentedata mist', 'neutral', errorMsg);
            results.fedStance = {value:null, colorClass:'neutral', name:"Fed Beleid", detail:"Rentedata mist", detailFull:"Rentedata 10j mist voor Fed Stance afleiding."};
        }

        console.log("Ophalen CoinGecko global data...");
        const cgData = await fetchCoinGeckoGlobalData();
        if (cgData) { Object.assign(results, cgData); }

        console.log("Berekenen ETH/BTC Ratio...");
        results.ethBtcRatioTrend = await calculateEthBtcRatio(results.btcPriceTrend, results.ethPriceTrend);

        console.log("Updaten van marktconditiekaarten...");
        updateGeneralMarketCondition(results);
        updateCryptoMarketCondition(results);
        updateStockMarketCondition(results);

        document.getElementById('lastUpdated').textContent = `Laatst bijgewerkt: ${formatDate(new Date())}`;
        console.log("loadDashboardData voltooid.");
    }

    console.log("Event listener voor window.onload wordt ingesteld.");
    window.onload = loadDashboardData;
    // setInterval(loadDashboardData, 15 * 60 * 1000); 

    console.log("Script einde bereikt (synchroon deel).");
</script>
</body>
</html>
