<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geavanceerd Swingtrade Dashboard v2.8</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0;
            background-color: #f0f2f5; color: #333; padding: 12px;
        }
        .dashboard-header { text-align: center; margin-bottom: 12px; }
        .dashboard-header h1 { margin-bottom: 4px; color: #1f2937; font-size: 1.7em; }
        .dashboard-header p { font-size: 0.85em; color: #6b7280; margin-top:0; }

        .grid-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(330px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .card { background-color: #fff; border-radius: 8px; padding: 18px; box-shadow: 0 3px 5px rgba(0,0,0,0.05); }
        .card h2 { margin-top: 0; margin-bottom: 15px; font-size: 1.2em; color: #374151; border-bottom: 1px solid #e5e7eb; padding-bottom: 10px; }
        
        /* --- START Inklapbare sectie stijlen --- */
        .card .collapsible-trigger { cursor: pointer; position: relative; }
        .card .collapsible-trigger::after {
            content: ' â–¼'; /* Pijltje omlaag */
            font-size: 0.7em;
            position: absolute;
            right: 0px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease-in-out;
        }
        .card.collapsed .collapsible-trigger::after {
            transform: translateY(-50%) rotate(-90deg); /* Pijltje links */
        }
        .collapsible-content {
            /* Standaard zichtbaar, JS handelt display:none af */
        }
        /* --- EINDE Inklapbare sectie stijlen --- */

        .indicator { padding: 9px 11px; margin-bottom: 9px; border-radius: 5px; font-size: 0.9em; border: 1px solid transparent; }
        .indicator strong { display: block; margin-bottom: 3px; color: #111827; font-weight: 600; font-size:0.93em; }
        /* --- START Sterrenscore stijlen --- */
        .indicator strong .stars {
            font-size: 0.9em;
            margin-left: 8px;
            color: #ffd700; /* Goudkleur */
            letter-spacing: 1px;
        }
        .indicator strong .stars .dimmed {
            color: #ccc;
        }
        /* --- EINDE Sterrenscore stijlen --- */
        .indicator span { font-size: 0.83em; color: #4b5563; }
        .indicator .action-hint { font-size: 0.75em; color: #555; display: block; margin-top: 4px; font-style: italic;}


        .green { background-color: #dcfce7; border-color: #86efac; border-left: 4px solid #22c55e; }
        .yellow { background-color: #fef9c3; border-color: #fde047; border-left: 4px solid #eab308; }
        .red { background-color: #fee2e2; border-color: #fca5a5; border-left: 4px solid #ef4444; }
        .neutral { background-color: #f3f4f6; border-color: #d1d5db; border-left: 4px solid #6b7280; }

        .crypto-market-card .indicator.yellow {
            background-color: #fef3c7; border-color: #f59e0b;
            border-left-width: 4px; border-left-color: #f59e0b;
        }
        .crypto-market-card .indicator.yellow strong,
        .crypto-market-card .indicator.yellow span { color: #78350f; }

        .condition-card {
            color: white; padding: 18px; border-radius: 8px; text-align: center;
            box-shadow: 0 4px 7px rgba(0,0,0,0.1); margin-bottom: 15px;
        }
        .condition-card h2 { margin-top: 0; color: white; border-bottom: none; font-size: 1.3em; }
        .condition-card p.status-text { font-size: 1.05em; margin-bottom: 8px; font-weight: bold; }
        .condition-card .factors-title { font-size: 0.75em; margin-top:10px; margin-bottom:3px; text-transform: uppercase; opacity:0.85; font-weight:600;}
        .condition-card .factors-list { font-size: 0.75em; opacity: 0.95; list-style-type: none; padding-left:0; margin:0 auto; max-width: 95%;}
        .condition-card .factors-list li { margin-bottom: 2px; text-align: left; padding-left: 5px; border-radius:3px; padding-top:1px; padding-bottom:1px;}
        .condition-card .factors-list li:hover { background-color: rgba(0,0,0,0.05); }
        .factors-list .factor-positive::before { content: 'ðŸŸ¢ '; font-size:0.75em; }
        .factors-list .factor-negative::before { content: 'ðŸ”´ '; font-size:0.75em; }
        /* --- START Strategie Hint Stijl --- */
        .condition-card .strategy-hint-title { font-size: 0.75em; margin-top:12px; margin-bottom:3px; text-transform: uppercase; opacity:0.85; font-weight:600;}
        .condition-card .strategy-hint-text { font-size: 0.85em; opacity: 0.95; font-style: italic; margin-bottom: 0;}
        /* --- EINDE Strategie Hint Stijl --- */

        .very-positive { background-color: #16a34a; } .positive { background-color: #22c55e; }
        .negative { background-color: #f97316; } .very-negative { background-color: #dc2626; }
        .condition-neutral { background-color: #6b7280; }

        .sub-conditions-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px; margin-bottom: 15px; }
        .sub-condition-card h2 { font-size: 1.15em; } .sub-condition-card p.status-text { font-size: 0.95em; }

        #bitcoinAltcoinSentiment.indicator { background-color: rgba(0,0,0,0.05); color: white; }
        #bitcoinAltcoinSentiment.indicator.green { border-left-color: #a7f3d0; }
        #bitcoinAltcoinSentiment.indicator.yellow { border-left-color: #fef08a; }
        #bitcoinAltcoinSentiment.indicator strong { color: white; opacity: 0.9; }
        #bitcoinAltcoinSentiment.indicator span { color: white; opacity: 0.8; }

        .loading { opacity: 0.7; }
        .error { color: #b91c1c; font-size: 0.75em; display: block; margin-top: 2px; font-weight:500; }
        .api-key-note { font-size:0.65em; color:#a1a1aa; margin-top:7px; text-align: right;}

        .tradingview-container { margin-top: 15px; padding: 12px; background-color: #fff; border-radius: 8px; box-shadow: 0 3px 5px rgba(0,0,0,0.05); }
        .tradingview-container h2 { margin-top: 0; margin-bottom: 12px; font-size: 1.2em; color: #374151; }
        #tradingview-widget-placeholder { height: 550px; width: 100%;}
        #tradingview-widget-placeholder > .tradingview-widget-container__widget { height: 100% !important; width: 100% !important; }
    </style>
</head>
<body>

    <div class="dashboard-header">
        <h1>Geavanceerd Swingtrade Dashboard v2.8</h1>
        <p title="Alle data wordt periodiek ververst. Trends voor crypto dominantie/ratio's worden zichtbaar na de tweede data-ophaling.">
            Analyse van macro, sentiment & marktindicatoren. <span id="lastUpdated"></span>
        </p>
    </div>

    <div class="grid-container">
        <div class="card collapsible">
            <h2 class="collapsible-trigger" title="Indicatoren die de algemene economische gezondheid en het beleid weerspiegelen.">Macro Omgeving</h2>
            <div class="collapsible-content">
                <div id="m2Trend" class="indicator loading" data-stars="2" title="M2 Geldhoeveelheid: Brede maatstaf voor de geldhoeveelheid in een economie. Stijgend kan duiden op meer liquiditeit."><strong>M2 Geldhoeveelheid Trend</strong><span>Laden...</span></div>
                <div id="interest10yrTrend" class="indicator loading" data-stars="3" title="10-Year Treasury Yield: Rente op Amerikaanse staatsobligaties met een looptijd van 10 jaar. Dalend is vaak positief voor activa."><strong>Rente Trend (10jr Treasury)</strong><span>Laden...</span></div>
                <div id="interest2yrTrend" class="indicator loading" data-stars="2" title="2-Year Treasury Yield: Rente op Amerikaanse staatsobligaties met een looptijd van 2 jaar."><strong>Rente Trend (2jr Treasury)</strong><span>Laden...</span></div>
                <div id="yieldCurve" class="indicator loading" data-stars="3" title="Yield Curve (10jr - 2jr): Verschil tussen 10-jaars en 2-jaars rente. Een inverse curve (negatief) kan een recessie voorspellen."><strong>Yield Curve (10j - 2j)</strong><span>Laden...</span></div>
                <div id="fedStance" class="indicator loading" data-stars="3" title="Fed Beleid Stance: Interpretatie van het monetaire beleid van de Federal Reserve (Amerikaanse centrale bank), afgeleid van rentetrends."><strong>Fed Beleid Stance</strong><span>Laden...</span></div>
                <div id="unemploymentTrend" class="indicator loading" data-stars="2" title="Werkloosheidspercentage: Percentage van de beroepsbevolking dat werkloos is. Dalend is positief."><strong>Werkloosheid Trend</strong><span>Laden...</span></div>
                <div id="inflationTrend" class="indicator loading" data-stars="3" title="Consumer Price Index (CPI): Maatstaf voor inflatie. Dalende inflatie kan druk op de Fed verminderen."><strong>Inflatie Trend (CPI Index)</strong><span>Laden...</span></div>
                <div id="ppiTrend" class="indicator loading" data-stars="1" title="Producenten Prijs Index (PPI): Voorlopende indicator voor consumenteninflatie. Stijgend is negatief."><strong>PPI Trend</strong><span>Laden...</span></div>
                <div id="breakeven10yrTrend" class="indicator loading" data-stars="2" title="10-Year Breakeven Inflation Rate: Marktverwachting voor inflatie over de komende 10 jaar. Stijgend is negatief."><strong>10jr Inflatieverwachting</strong><span>Laden...</span></div>
                <div id="retailSalesTrend" class="indicator loading" data-stars="2" title="Detailhandelsverkopen: Totale verkopen van detailhandelszaken. Stijgend duidt op sterke consumentenuitgaven."><strong>Retail Sales Trend</strong><span>Laden...</span></div>
                <div id="ismPmiTrend" class="indicator loading" data-stars="2" title="ISM Manufacturing Purchasing Managers' Index: Index voor de productiesector. Boven 50 duidt op expansie."><strong>ISM Manufacturing PMI</strong><span>Laden...</span></div>
                <div class="api-key-note">Macro data vereist FRED API Key.</div>
            </div>
        </div>

        <div class="card collapsible">
            <h2 class="collapsible-trigger" title="Indicatoren die de richting van kapitaalstromen en de status van globale activa weerspiegelen.">Geldstroom & Globale Indicatoren</h2>
            <div class="collapsible-content">
                <div id="dxyTrend" class="indicator loading" data-stars="3" title="US Dollar Index (DXY): Waarde van de US dollar."><strong>US Dollar Index (DXY) Trend</strong><span>Laden...</span></div>
                <div id="goldTrend" class="indicator loading" data-stars="1" title="Goudprijs via GLD ETF (proxy voor Goud XAU/USD)"><strong>Goud ETF (GLD) Trend</strong><span>Laden...</span></div>
                <div id="oilTrend" class="indicator loading" data-stars="2" title="Olieprijs via USO ETF (proxy voor WTI Crude)"><strong>Olie ETF (USO) Trend</strong><span>Laden...</span></div>
                <div id="copperTrend" class="indicator loading" data-stars="2" title="Koperprijs via CPER ETF: Barometer voor wereldwijde economische gezondheid. Stijgend is positief."><strong>Koper ETF (CPER)</strong><span>Laden...</span></div>
                <div id="bondSpreadsTrend" class="indicator loading" data-stars="3" title="High Yield Corporate Bond Spreads: Verschil in rente tussen risicovolle bedrijfsobligaties en veilige staatsobligaties. Dalende spreads zijn positief."><strong>High Yield Bond Spreads</strong><span>Laden...</span></div>
                <div class="api-key-note">Goud, Olie, Koper (ETF's): Finnhub/FMP API Key. Spreads: FRED API Key. DXY: FMP API Key.</div>
            </div>
        </div>

        <div class="card collapsible">
            <h2 class="collapsible-trigger" title="Metingen van het algemene gevoel of de psychologie van investeerders.">Markt Sentiment</h2>
            <div class="collapsible-content">
                <div id="cryptoFearGreed" class="indicator loading" data-stars="2" title="Crypto Fear & Greed Index: Meet het sentiment in de cryptomarkt. Contra-indicator."><strong>Crypto Fear & Greed Index</strong><span>Laden...</span></div>
                <div id="stockFearGreedVIX" class="indicator loading" data-stars="2" title="Volatility Index (VIX) als proxy voor Aandelen F&G. Contra-indicator."><strong>Aandelen F&G (VIX)</strong><span>Laden...</span></div>
                <div class="api-key-note">VIX: Finnhub API Key.</div>
            </div>
        </div>

        <div class="card crypto-market-card collapsible">
            <h2 class="collapsible-trigger" title="Indicatoren specifiek voor de interne dynamiek van de cryptomarkt.">Crypto Markt Intern</h2>
            <div class="collapsible-content">
                <div id="btcPriceTrend" class="indicator loading" data-stars="1" title="Bitcoin (BTC) Prijs Trend"><strong>Bitcoin (BTC) Prijs Trend</strong><span>Laden...</span></div>
                <div id="ethPriceTrend" class="indicator loading" data-stars="1" title="Ethereum (ETH) Prijs Trend"><strong>Ethereum (ETH) Prijs Trend</strong><span>Laden...</span></div>
                <div id="btcDominanceTrend" class="indicator loading" data-stars="2" title="Bitcoin Dominantie (BTC.D). Dalend is vaak altcoin-positief."><strong>Bitcoin Dominantie (BTC.D)</strong><span>Laden...</span></div>
                <div id="ethDominanceTrend" class="indicator loading" data-stars="2" title="Ethereum Dominantie (ETH.D). Stijgend is vaak altcoin-positief."><strong>Ethereum Dominantie (ETH.D)</strong><span>Laden...</span></div>
                <div id="altcoinMarketCapTrend" class="indicator loading" data-stars="3" title="Altcoin Market Cap (Ex-BTC). Stijgend is altcoin-positief."><strong>Altcoin Market Cap (Ex-BTC)</strong><span>Laden...</span></div>
                <div id="ethBtcRatioTrend" class="indicator loading" data-stars="3" title="ETH/BTC Ratio Trend. Stijgend is ETH/altcoin-positief tov BTC."><strong>ETH/BTC Ratio Trend</strong><span>Laden...</span></div>
                <div class="api-key-note">Trends voor dominanties/ratio zichtbaar na 2e refresh.</div>
            </div>
        </div>

        <div class="card collapsible">
            <h2 class="collapsible-trigger" title="Trends van belangrijke aandelenindices.">Traditionele Markten (Indices)</h2>
            <div class="collapsible-content">
                <div id="sp500Trend" class="indicator loading" data-stars="2" title="S&P 500 Index (via SPY ETF)"><strong>S&P 500 Trend</strong><span>Laden...</span></div>
                <div id="nasdaq100Trend" class="indicator loading" data-stars="2" title="Nasdaq 100 Index (via QQQ ETF)"><strong>Nasdaq 100 Trend</strong><span>Laden...</span></div>
                <div id="russell2000Trend" class="indicator loading" data-stars="1" title="Russell 2000 Index (via IWM ETF): Small-cap aandelen. Stijgend is positief."><strong>Russell 2000 (IWM ETF)</strong><span>Laden...</span></div>
                <div class="api-key-note">Indices (ETF's): Finnhub/FMP API Key.</div>
            </div>
        </div>
    </div>

    <div id="generalMarketCondition" class="condition-card condition-neutral">
        <h2 title="Een gewogen samenvatting van alle belangrijke indicatoren om een algemeen beeld te vormen.">Algemene Marktconditie</h2>
        <p id="generalMarketText" class="status-text">Laden...</p>
        <div class="factors-title">Belangrijkste Factoren (Max. 3 Positief / 3 Negatief):</div>
        <ul id="generalMarketFactors" class="factors-list"><li>Laden...</li></ul>
        <div class="strategy-hint-title">Strategie Hint</div>
        <p id="generalMarketStrategy" class="strategy-hint-text">Analyse wordt geladen...</p>
    </div>
    <div class="sub-conditions-grid">
        <div id="cryptoMarketCondition" class="condition-card condition-neutral sub-condition-card">
            <h2 title="Specifieke analyse voor de cryptomarkt.">Crypto Marktconditie</h2>
            <p id="cryptoMarketText" class="status-text">Laden...</p>
            <div class="factors-title">Belangrijkste Crypto Factoren:</div>
            <ul id="cryptoMarketFactors" class="factors-list"><li>Laden...</li></ul>
            <div id="bitcoinAltcoinSentiment" class="indicator neutral" style="margin-top:12px; padding:7px;">
                <strong title="Geeft aan of het sentiment meer richting Bitcoin of altcoins neigt.">Bitcoin vs. Altcoin Sentiment</strong>
                <span>Laden...</span>
            </div>
            <div class="strategy-hint-title">Crypto Strategie Hint</div>
            <p id="cryptoMarketStrategy" class="strategy-hint-text">Analyse wordt geladen...</p>
        </div>
        <div id="stockMarketCondition" class="condition-card condition-neutral sub-condition-card">
            <h2 title="Specifieke analyse voor de aandelenmarkt.">Aandelen Marktconditie</h2>
            <p id="stockMarketText" class="status-text">Laden...</p>
            <div class="factors-title">Belangrijkste Aandelen Factoren:</div>
            <ul id="stockMarketFactors" class="factors-list"><li>Laden...</li></ul>
            <div class="strategy-hint-title">Aandelen Strategie Hint</div>
            <p id="stockMarketStrategy" class="strategy-hint-text">Analyse wordt geladen...</p>
        </div>
    </div>

    <div class="tradingview-container card collapsible"> <!-- TradingView ook inklapbaar gemaakt -->
        <h2 class="collapsible-trigger">TradingView Grafiek</h2>
        <div class="collapsible-content">
            <div id="tradingview-widget-placeholder">
                <!-- TradingView Widget BEGIN -->
                <div class="tradingview-widget-container" style="height:100%;width:100%">
                  <div class="tradingview-widget-container__widget" style="height:calc(100% - 32px);width:100%"></div>
                  <div class="tradingview-widget-copyright"><a href="https://www.tradingview.com/" rel="noopener nofollow" target="_blank"><span class="blue-text">Track all markets on TradingView</span></a></div>
                  <script type="text/javascript" src="https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js" async>
                  {
                  "autosize": true,
                  "symbol": "NASDAQ:AAPL",
                  "interval": "D",
                  "timezone": "Europe/Amsterdam",
                  "theme": "light",
                  "style": "1",
                  "locale": "en",
                  "allow_symbol_change": true,
                  "watchlist": [
                    "BINANCE:BTCUSDT",
                    "BINANCE:SOLBTC",
                    "BINANCE:ETHUSD",
                    "BINANCE:ETHBTC",
                    "COINBASE:SOLUSD",
                    "SP:SPX",
                    "MIL:VUAA",
                    "CRYPTOCAP:OTHERS",
                    "CRYPTOCAP:BTC.D"
                  ],
                  "hotlist": true,
                  "studies": [
                    "STD;RSI",
                    "STD;Stochastic_RSI"
                  ],
                  "support_host": "https://www.tradingview.com"
                }
                  </script>
                </div>
                <!-- TradingView Widget END -->
            </div>
        </div>
    </div>

<script>
    // ---- API KEYS (ZEER BELANGRIJK: VUL DEZE IN!) ----
    console.log("Script gestart. API Keys initialiseren...");
    const FRED_API_KEY = '6eb928143eef77787366d5af41104d3e'; 
    const FINNHUB_API_KEY = 'd106impr01qhkqr86m9gd106impr01qhkqr86ma0'; 
    const FMP_API_KEY = 'Xpob3mGH7hEF2MT39Ev96ismedWfeXGT';   

    console.log("FRED Key:", FRED_API_KEY ? "Ingevuld" : "LEEG!");
    console.log("Finnhub Key:", FINNHUB_API_KEY ? "Ingevuld" : "LEEG!");
    console.log("FMP Key:", FMP_API_KEY ? "Ingevuld" : "LEEG!");

    // ---- GLOBALE VARIABELEN VOOR TRENDS ----
    let previousBtcDom = null, previousEthDom = null, previousAltCap = null, previousEthBtcRatio = null;

    // ---- Helper Functies ----
    function setIndicator(elementId, title, detail, colorClass, error = null, actionHint = null) {
        const element = document.getElementById(elementId);
        if (!element) { console.error("Element niet gevonden voor setIndicator:", elementId); return; }
        
        element.classList.remove('loading', 'green', 'yellow', 'red', 'neutral');
        if (colorClass) element.classList.add(colorClass);
        
        const strongElement = element.querySelector('strong') || document.createElement('strong');
        strongElement.textContent = title;
        
        // Sterren toevoegen
        const stars = element.dataset.stars;
        if (stars) {
            let starHTML = ' <span class="stars">';
            for (let i = 0; i < 3; i++) {
                starHTML += i < parseInt(stars) ? 'â˜…' : '<span class="dimmed">â˜†</span>';
            }
            starHTML += '</span>';
            strongElement.innerHTML = title + starHTML; // Pas op, dit overschrijft eventuele bestaande HTML in strong, maar voor tekst + sterren is het ok.
        }


        const spanElement = element.querySelector('span:not(.error):not(.action-hint)') || document.createElement('span');
        spanElement.textContent = detail;
        
        // Verwijder bestaande elementen behalve de strong-tag voor de tooltip
        // en de action-hint als die al bestaat
        let currentStrong = element.querySelector('strong');
        let currentActionHint = element.querySelector('.action-hint');
        element.innerHTML = ''; 
        if(currentStrong) element.appendChild(strongElement); // Gebruik de bijgewerkte strongElement
        else element.appendChild(strongElement);

        element.appendChild(spanElement);

        if (currentActionHint) element.appendChild(currentActionHint); // Voeg oude hint weer toe als die er was

        // Actiehint afhandelen
        let hintElement = element.querySelector('.action-hint');
        if (actionHint) {
            if (!hintElement) {
                hintElement = document.createElement('span');
                hintElement.className = 'action-hint';
                element.appendChild(hintElement);
            }
            hintElement.textContent = actionHint;
        } else if (hintElement) {
            // hintElement.remove(); // Verwijder als er geen nieuwe hint is en er een oude was (optioneel)
        }
        
        const oldErrorSpan = element.querySelector('span.error');
        if (oldErrorSpan) oldErrorSpan.remove(); 
        
        if (error) {
            const errorSpan = document.createElement('span');
            errorSpan.className = 'error'; 
            errorSpan.textContent = error; 
            element.appendChild(errorSpan);
        }
    }
    function formatDate(date) { return date.toLocaleString('nl-NL', { dateStyle: 'medium', timeStyle: 'short' }); }
    document.getElementById('lastUpdated').textContent = `Laatst bijgewerkt: ${formatDate(new Date())}`;

    const apiCache = new Map();
    const CACHE_DURATION = 5 * 60 * 1000; 
    async function fetchWithCache(url, options = {}, parser = 'json') {
        const now = Date.now();
        if (apiCache.has(url)) {
            const { timestamp, data } = apiCache.get(url);
            if (now - timestamp < CACHE_DURATION) { 
                console.log("Cache HIT for URL:", url.substring(0,120));
                return data; 
            }
        }
        console.log("Fetching URL (Cache MISS/EXPIRED):", url.substring(0,120));
        try {
            const response = await fetch(url, options);
            if (!response.ok) {
                let errorText = `Status: ${response.status}`;
                try { 
                    const errorBody = await response.text(); // Probeer altijd text te lezen voor details
                    errorText = `Status ${response.status}: ${errorBody.substring(0,200)}`;
                     if (errorBody.length > 200) errorText += "...";
                } catch (e) { console.warn("Kon error response body niet lezen:", e); }
                console.error(`API error! URL: ${url.substring(0,100)}. Details: ${errorText}`);
                throw new Error(`API Fout: ${errorText}`); // Gooi de meer gedetailleerde error
            }
            let responseData;
            // Voor allorigins.win/raw?url=... komt de data als text, zelfs als het JSON is.
            // We moeten het dan handmatig parsen.
            if (url.includes('api.allorigins.win/raw')) {
                const textData = await response.text();
                try {
                    responseData = JSON.parse(textData);
                } catch (e) {
                    console.error("Failed to parse JSON from proxy for URL:", url, e);
                    console.error("Proxy response text:", textData.substring(0,500)); // Log deel van de response
                    throw new Error("Proxy JSON Parse Fout");
                }
            } else if (parser === 'json') {
                 responseData = await response.json();
            } else if (parser === 'text') {
                 responseData = await response.text();
            } else {
                 responseData = response; 
            }
            apiCache.set(url, { timestamp: now, data: responseData });
            return responseData;
        } catch (error) {
            console.error("fetchWithCache FAILED for ", url.substring(0,80), error);
            throw error; 
        }
    }

    function setMarketConditionCard(cardId, textId, factorsId, strategyId, scorePercentage, conditionText, positiveFactors, negativeFactors, numSignals, strategyHint) {
        const cardElement = document.getElementById(cardId);
        const textElement = document.getElementById(textId);
        const factorsElement = document.getElementById(factorsId);
        const strategyElement = document.getElementById(strategyId);

        if (!cardElement || !textElement || !factorsElement || !strategyElement) { console.error("Conditiekaart element (of strategie) niet gevonden:", cardId); return; }
        
        cardElement.classList.remove('very-positive', 'positive', 'negative', 'very-negative', 'condition-neutral', 'loading');
        if (conditionText.toLowerCase().includes("onvoldoende data") || conditionText.toLowerCase().includes("api key")) { cardElement.classList.add('condition-neutral'); }
        else if (scorePercentage > 55) cardElement.classList.add('very-positive'); else if (scorePercentage > 15) cardElement.classList.add('positive');
        else if (scorePercentage < -55) cardElement.classList.add('very-negative'); else if (scorePercentage < -15) cardElement.classList.add('negative');
        else cardElement.classList.add('condition-neutral');
        
        textElement.textContent = conditionText;
        textElement.title = `Score: ${scorePercentage.toFixed(0)}% (${numSignals} signalen)`;
        
        let factorsHTML = '';
        positiveFactors.slice(0, 3).forEach(factor => factorsHTML += `<li class="factor-positive" title="${factor.name}: ${factor.detailFull || factor.detail}">${factor.name}: ${factor.detail}</li>`);
        negativeFactors.slice(0, 3).forEach(factor => factorsHTML += `<li class="factor-negative" title="${factor.name}: ${factor.detailFull || factor.detail}">${factor.name}: ${factor.detail}</li>`);
        const totalFactors = positiveFactors.length + negativeFactors.length;
        const anyKeyMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === '' || FMP_API_KEY === '';
        if (numSignals === 0 && anyKeyMissing) { factorsHTML = '<li title="Zonder API keys kan geen volledige analyse worden gemaakt.">API Key(s) niet geconfigureerd.</li>'; }
        else if (numSignals < 3 && !anyKeyMissing) { factorsHTML = `<li title="Er zijn te weinig datapunten beschikbaar voor een betrouwbare lijst van factoren.">Onvoldoende data (${numSignals} signaal/en).</li>`; }
        else if (totalFactors === 0 && numSignals > 0) { factorsHTML = `<li title="De meeste indicatoren geven een neutraal beeld, of heffen elkaar op.">Geen sterk positieve/negatieve factoren.</li>`; }
        else if (factorsHTML === '') { factorsHTML = '<li title="Wacht tot alle data is geladen, of controleer de API keys.">Analyse data wordt geladen...</li>'; }
        factorsElement.innerHTML = factorsHTML;

        strategyElement.textContent = strategyHint || "Bepaal strategie o.b.v. conditie.";
    }

    // ---- Data Ophalingsfuncties ----
    async function fetchFredSeries(seriesId, elementName, title, positiveChangeIsGood = true, unit = "%", valueMultiplier = 1, higherIsBetterThreshold = null) {
        const defaultReturn = { value: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood, change: null };
        let actionHint = null;

        if (FRED_API_KEY === '' || !FRED_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel FRED API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'FRED API Key niet geconfigureerd.' };
        }
        
        const fredUrl = `https://api.stlouisfed.org/fred/series/observations?series_id=${seriesId}&api_key=${FRED_API_KEY}&file_type=json&limit=2&sort_order=desc`;
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(fredUrl)}`;
        console.log("Fetching FRED via Proxy:", proxyUrl.substring(0,150) + (proxyUrl.length > 150 ? "..." : "") ); // Kortere log

        try {
            const data = await fetchWithCache(proxyUrl); 
            const observations = data.observations;

            if (observations && observations.length > 0) {
                const latestObs = observations[0];
                if (latestObs.value === "." || isNaN(parseFloat(latestObs.value))) {
                     setIndicator(elementName, title, 'Data ongeldig (FRED)', 'neutral', 'Ongeldige waarde');
                     return { ...defaultReturn, detail: 'Ongeldige data (FRED)', detailFull: 'Recente data van FRED is ongeldig.' };
                }
                const latestValue = parseFloat(latestObs.value) * valueMultiplier;
                let previousValue = null; let change = null;
                let trendText = `${latestValue.toFixed(2)}${unit}`; let colorClass = 'yellow';
                let trendDescription = "Stabiel";

                if (observations.length >= 2 && observations[1].value !== "." && !isNaN(parseFloat(observations[1].value))) {
                    previousValue = parseFloat(observations[1].value) * valueMultiplier; change = latestValue - previousValue;
                    const relChangeThreshold = 0.0005; 
                    if (change > Math.abs(previousValue * relChangeThreshold) || (previousValue === 0 && change > 0.0001 * valueMultiplier)) { 
                        colorClass = positiveChangeIsGood ? 'green' : 'red'; trendDescription = "Stijgend";
                    } else if (change < -Math.abs(previousValue * relChangeThreshold) || (previousValue === 0 && change < -0.0001 * valueMultiplier)) { 
                        colorClass = positiveChangeIsGood ? 'red' : 'green'; trendDescription = "Dalend";
                    }
                }

                if (higherIsBetterThreshold !== null) {
                    const thresholdOffset = unit === "%" ? 0.2 : 1.5;
                    if (latestValue > higherIsBetterThreshold + thresholdOffset ) { 
                         colorClass = 'green'; trendDescription = latestValue > higherIsBetterThreshold ? `Boven ${higherIsBetterThreshold}` : trendDescription;
                    } else if (latestValue < higherIsBetterThreshold - thresholdOffset ) {
                         colorClass = 'red'; trendDescription = latestValue < higherIsBetterThreshold ? `Onder ${higherIsBetterThreshold}` : trendDescription;
                    } else { 
                         colorClass = 'yellow'; trendDescription = `Rond ${higherIsBetterThreshold}`;
                    }
                }
                
                // Voorbeeld van actionHint toevoegen
                if (title.includes("M2") && colorClass === "green") actionHint = "Meer liquiditeit, gunstig voor risico-activa.";
                else if (title.includes("Rente") && colorClass === "green") actionHint = "Lagere rente, positief voor groei/aandelen.";
                else if (title.includes("Yield Curve") && colorClass === "red") actionHint = "Inverse curve, recessie-risico. Wees voorzichtig.";


                let fullDetailText = `${trendText} (${trendDescription})`;
                setIndicator(elementName, title, fullDetailText, colorClass, null, actionHint);
                return { value: latestValue, colorClass, name: title, detail: trendText.split('(')[0].trim(), detailFull: fullDetailText, positiveChangeIsGood, change };
            } else { 
                setIndicator(elementName, title, 'Geen data (FRED)', 'neutral', 'Geen observaties van FRED.'); 
                return { ...defaultReturn, detail: 'Geen data (FRED)', detailFull:'Geen observaties van FRED. Mogelijk 404 via proxy.' };
            }
        } catch (error) {
            let errMsg = error.message || "Failed to fetch (FRED via Proxy)";
             if (errMsg.includes("API Fout: Status 404") || (error.message && error.message.includes("Not Found"))) {
                errMsg = `FRED API 404: ${seriesId} niet gevonden.`;
            } else if (errMsg.includes("Proxy JSON Parse Fout")) {
                errMsg = "Proxy kon FRED response niet parsen. Check console.";
            }
            console.error(`Error in fetchFredSeries (via Proxy) for ${seriesId}:`, error);
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }
    
    // ... (Rest van de fetchFmpQuote, fetchFinnhubQuote, fetchCryptoFearGreed, fetchCryptoPrice, fetchCoinGeckoGlobalData, calculateEthBtcRatio komen HIER) ...
    // ... (Deze functies blijven zoals ze waren in je vorige werkende versie) ...

    async function fetchFmpQuote(symbol, elementName, title, positiveChangeIsGood = true, isIndexType = true) {
        const defaultReturn = { value: null, changePercent: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood };
        if (FMP_API_KEY === '' || !FMP_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel FMP API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'FMP API Key niet geconfigureerd.' };
        }
        const url = `https://financialmodelingprep.com/api/v3/quote/${symbol}?apikey=${FMP_API_KEY}`;
        try {
            const data = await fetchWithCache(url); 
            if (data && data.length > 0 && data[0].changesPercentage !== undefined && data[0].price !== undefined) {
                const quote = data[0];
                const price = parseFloat(quote.price);
                const changePercent = parseFloat(quote.changesPercentage);

                if (isNaN(price) || isNaN(changePercent)) {
                    setIndicator(elementName, title, 'Ongeldige data (FMP)', 'neutral', 'Ongeldige waarde FMP');
                    return { ...defaultReturn, detail: 'Ongeldige data (FMP)', detailFull: 'Ongeldige data van FMP.' };
                }
                let colorClass;
                const threshold = isIndexType ? 0.10 : 0.30; 
                if (changePercent > threshold) { colorClass = positiveChangeIsGood ? 'green' : 'red'; }
                else if (changePercent < -threshold) { colorClass = positiveChangeIsGood ? 'red' : 'green'; }
                else { colorClass = 'yellow'; }
                let fullDetailText = `${price.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                setIndicator(elementName, title, fullDetailText, colorClass);
                return { value: price, changePercent, colorClass, name: title, detail: price.toFixed(2), detailFull: fullDetailText, positiveChangeIsGood };
            } else if (data && data.length > 0 && data[0]["Error Message"]) { 
                let errMsg = data[0]["Error Message"];
                 if(errMsg.toLowerCase().includes("limit exceeded") || errMsg.toLowerCase().includes("invalid api key")) errMsg = "FMP API Limiet/Key Probleem";
                setIndicator(elementName, title, `FMP: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `FMP Error`, detailFull: `FMP API error: ${errMsg}` };
            } else if (data && data["Error Message"]) { 
                let errMsg = data["Error Message"];
                if(errMsg.toLowerCase().includes("limit exceeded") || errMsg.toLowerCase().includes("invalid api key")) errMsg = "FMP API Limiet/Key Probleem";
                setIndicator(elementName, title, `FMP: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `FMP Error`, detailFull: `FMP API error: ${errMsg}` };
            }
             else {
                let noDataMsg = 'Geen data (FMP)';
                if (data && data.length === 0) noDataMsg = 'Lege response (FMP)';
                setIndicator(elementName, title, noDataMsg, 'neutral', 'Mogelijk ongeldig symbool of API probleem.');
                return { ...defaultReturn, detail: noDataMsg, detailFull: `${noDataMsg} (mogelijk ongeldig symbool, API key probleem of geen data voor symbool van FMP).` };
            }
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
             if (error.message && (error.message.includes("API Fout: 401") || error.message.includes("API Fout: 403"))){ errMsg = "FMP API Key ongeldig/geblokkeerd"; }
             else if (error.message && error.message.includes("API Fout: 429")){ errMsg = "FMP API Limiet bereikt"; }
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchFinnhubQuote(symbol, elementName, title, positiveChangeIsGood = true, isIndexType = true) {
        const defaultReturn = { value: null, changePercent: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', positiveChangeIsGood };
        if (FINNHUB_API_KEY === '' || !FINNHUB_API_KEY) {
            setIndicator(elementName, title, 'Data Error', 'neutral', 'Koppel Finnhub API Key');
            return { ...defaultReturn, detail: 'API Key Mist', detailFull: 'Finnhub API Key niet geconfigureerd.' };
        }
        const url = `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${FINNHUB_API_KEY}`;
        try {
            const data = await fetchWithCache(url);
            if (data && data.c !== undefined && data.dp !== undefined && data.t !== 0) { // Check data.t !== 0 to avoid stale data
                const price = parseFloat(data.c); const changePercent = parseFloat(data.dp);
                if (isNaN(price) || isNaN(changePercent)) {
                    setIndicator(elementName, title, 'Ongeldige data (FH)', 'neutral', 'Ongeldige waarde FH');
                    return { ...defaultReturn, detail: 'Ongeldige data', detailFull: 'Ongeldige data van Finnhub.' };
                }
                let colorClass; const threshold = isIndexType ? 0.15 : 0.4; 
                if (changePercent > threshold) { colorClass = positiveChangeIsGood ? 'green' : 'red'; }
                else if (changePercent < -threshold) { colorClass = positiveChangeIsGood ? 'red' : 'green'; }
                else { colorClass = 'yellow'; }
                let fullDetailText = `${price.toFixed(2)} (${changePercent >= 0 ? '+' : ''}${changePercent.toFixed(2)}%)`;
                setIndicator(elementName, title, fullDetailText, colorClass);
                return { value: price, changePercent, colorClass, name: title, detail: price.toFixed(2), detailFull: fullDetailText, positiveChangeIsGood };
            } else if (data && data.error) {
                 let errMsg = data.error;
                 if(errMsg.toLowerCase().includes("invalid api key") || errMsg.toLowerCase().includes("please subscribe to get us stock data")) errMsg = "Finnhub API Key/Abo Probleem";
                setIndicator(elementName, title, `Finnhub: ${errMsg.substring(0,30)}`, 'neutral', errMsg);
                return { ...defaultReturn, detail: `Finnhub Error`, detailFull: `Finnhub API error: ${errMsg}` };
            } else if (data && (data.c === 0 || data.t === 0)){ 
                setIndicator(elementName, title, 'Geen data (Finnhub Nul/Stale)', 'neutral', 'Finnhub retourneerde nullen of oude data. Mogelijk onbekend/vertraagd symbool.');
                return { ...defaultReturn, detail: 'Geen data (FH Nul/Stale)', detailFull: 'Finnhub retourneerde nullen of oude data. Mogelijk onbekend/vertraagd symbool.' };
            }
            else {
                setIndicator(elementName, title, 'Geen data (Finnhub)', 'neutral', 'Mogelijk ongeldig symbool of API probleem.');
                return { ...defaultReturn, detail: 'Geen data (FH)', detailFull: 'Geen data van Finnhub (mogelijk ongeldig symbool of API probleem).' };
            }
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
             if (error.message && (error.message.includes("API Fout: 401") || error.message.includes("API Fout: 403"))){ errMsg = "Finnhub API Key ongeldig/geblokkeerd"; }
             else if (error.message && error.message.includes("API Fout: 429")){ errMsg = "Finnhub API Limiet bereikt"; }
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg);
            return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchCryptoFearGreed() {
        const title = "Crypto F&G"; const elementName = 'cryptoFearGreed';
        const defaultReturn = { value: null, classification: 'Laden...', colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        const url = 'https://api.alternative.me/fng/?limit=1&format=json';
        try {
            const data = await fetchWithCache(url);
            const value = parseInt(data.data[0].value); const classification = data.data[0].value_classification;
            let colorClass; let detailText = `${value} - ${classification}`; let isBullish = false, isBearish = false;
            if (value <= 25) { colorClass = 'green'; detailText = `${value} (Extr. Angst)`; isBullish = true; } 
            else if (value <= 45) { colorClass = 'yellow'; detailText = `${value} (Angst)`; }
            else if (value <= 55) { colorClass = 'neutral'; detailText = `${value} (Neutraal)`; }
            else if (value <= 75) { colorClass = 'yellow'; detailText = `${value} (Hebzucht)`; } 
            else { colorClass = 'red'; detailText = `${value} (Extr. Hebzucht)`; isBearish = true; } 
            setIndicator(elementName, title, detailText, colorClass);
            return { value, classification, colorClass, name: title, detail: classification, detailFull: detailText, isBullish, isBearish };
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg); return { ...defaultReturn, detail: 'Data Error', detailFull: errMsg };
        }
    }

    async function fetchCryptoPrice(coinId, elementName, title) {
        const defaultReturn = { value: null, change24h: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        const url = `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd&include_24hr_change=true`;
        try {
            const data = await fetchWithCache(url);
            if (!data || !data[coinId] || data[coinId].usd === undefined || data[coinId].usd_24h_change === undefined) {
                 setIndicator(elementName, title, 'Prijsdata ongeldig (CG)', 'neutral', 'Ongeldige waarde CG'); return {...defaultReturn, detail:'Ongeldige data (CG)', detailFull:'Ongeldige prijsdata van CoinGecko.'};
            }
            const price = data[coinId].usd; const change24h = data[coinId].usd_24h_change;
            let trendStatus, colorClass; let isBullish = false, isBearish = false;
            if (change24h > 1.5) { trendStatus = `Opwaarts`; colorClass = 'green'; isBullish = true;}
            else if (change24h < -1.5) { trendStatus = `Dalend`; colorClass = 'red'; isBearish = true;}
            else { trendStatus = `Zijwaarts`; colorClass = 'yellow'; }
            let fullDetailText = `${trendStatus} (${price.toFixed(price < 1 ? 4 : 2)} USD, ${change24h >= 0 ? '+' : ''}${change24h.toFixed(2)}% 24u)`;
            setIndicator(elementName, title, fullDetailText, colorClass);
            return { value: price, change24h, colorClass, name: title, detail: trendStatus, detailFull: fullDetailText, isBullish, isBearish };
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch";
            setIndicator(elementName, title, 'Data Error', 'neutral', errMsg); return {...defaultReturn, detail:'Data Error', detailFull: errMsg};
        }
    }

    async function fetchCoinGeckoGlobalData() {
        const defaultReturn = { btcDominanceTrend: null, ethDominanceTrend: null, altcoinMarketCapTrend: null };
        const url = 'https://api.coingecko.com/api/v3/global';
        try {
            const data = await fetchWithCache(url); const globalData = data.data; let results = {}; let trendStatus;

            const btcD = globalData.market_cap_percentage.btc; let btcDc = 'yellow', btcDt = `${btcD.toFixed(1)}% (Initieel)`; let btcDisB = false, btcDisBe = false;
            if (previousBtcDom !== null) { 
                if (btcD < previousBtcDom - 0.15) { btcDc = 'green'; trendStatus = "Dalend"; btcDisB = true;} 
                else if (btcD > previousBtcDom + 0.15) { btcDc = 'red'; trendStatus = "Stijgend"; btcDisBe = true;}
                else { trendStatus = "Stabiel";} btcDt = `${btcD.toFixed(1)}% (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('btcDominanceTrend', 'BTC Dominantie', btcDt, btcDc);
            results.btcDominanceTrend = { value: btcD, colorClass: btcDc, name: 'BTC Dominantie', detail: `${btcD.toFixed(1)}%`, detailFull: btcDt, isBullish: btcDisB, isBearish: btcDisBe };
            if (previousBtcDom === null && btcD !== undefined) previousBtcDom = btcD;

            const ethD = globalData.market_cap_percentage.eth; let ethDc = 'yellow', ethDt = `${ethD.toFixed(1)}% (Initieel)`; let ethDisB = false, ethDisBe = false;
            if (previousEthDom !== null) { 
                if (ethD > previousEthDom + 0.1) { ethDc = 'green'; trendStatus = "Stijgend"; ethDisB = true;}
                else if (ethD < previousEthDom - 0.1) { ethDc = 'red'; trendStatus = "Dalend"; ethDisBe = true;}
                else { trendStatus = "Stabiel";} ethDt = `${ethD.toFixed(1)}% (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('ethDominanceTrend', 'ETH Dominantie', ethDt, ethDc);
            results.ethDominanceTrend = { value: ethD, colorClass: ethDc, name: 'ETH Dominantie', detail: `${ethD.toFixed(1)}%`, detailFull: ethDt, isBullish: ethDisB, isBearish: ethDisBe };
            if (previousEthDom === null && ethD !== undefined) previousEthDom = ethD;

            const totalMC = globalData.total_market_cap.usd; const btcMC = btcD / 100 * totalMC; const altMC = totalMC - btcMC;
            const altMCf = (altMC / 1e9).toFixed(0); let altMCc = 'yellow', altMCt = `$${altMCf}B (Initieel)`; let altDisB = false, altDisBe = false;
            if (previousAltCap !== null) { 
                if (altMC > previousAltCap * 1.015) { altMCc = 'green'; trendStatus = "Stijgend"; altDisB = true;}
                else if (altMC < previousAltCap * 0.985) { altMCc = 'red'; trendStatus = "Dalend"; altDisBe = true;}
                else { trendStatus = "Stabiel";} altMCt = `$${altMCf}B (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator('altcoinMarketCapTrend', 'Altcoin MarketCap (Ex-BTC)', altMCt, altMCc);
            results.altcoinMarketCapTrend = { value: altMC, colorClass: altMCc, name: 'Altcoin MC', detail: `$${altMCf}B`, detailFull: altMCt, isBullish: altDisB, isBearish: altDisBe };
            if (previousAltCap === null && altMC !== undefined) previousAltCap = altMC;

            return results;
        } catch (error) {
            let errMsg = error.message && error.message.includes("API Fout:") ? error.message : "Failed to fetch CG Global";
            console.error('Error CoinGecko Global:', errMsg);
            setIndicator('btcDominanceTrend', 'BTC Dominantie', 'Data Error', 'neutral', errMsg);
            setIndicator('ethDominanceTrend', 'ETH Dominantie', 'Data Error', 'neutral', errMsg);
            setIndicator('altcoinMarketCapTrend', 'Altcoin MarketCap (Ex-BTC)', 'Data Error', 'neutral', errMsg);
            return defaultReturn;
        }
    }

    async function calculateEthBtcRatio(btcData, ethData) {
        const title = "ETH/BTC Ratio"; const elementName = 'ethBtcRatioTrend';
        const defaultReturn = { value: null, colorClass: 'neutral', name: title, detail: 'Laden...', detailFull: 'Laden...', isBullish: false, isBearish: false };
        if (btcData && btcData.value && ethData && ethData.value) {
            const ratio = ethData.value / btcData.value; let trendText = `${ratio.toFixed(5)} (Initieel)`, colorClass = 'yellow';
            let isBullish = false, isBearish = false; let trendStatus = "Initieel";
            if (previousEthBtcRatio !== null) { 
                if (ratio > previousEthBtcRatio * 1.0075) { trendStatus = "Stijgend"; colorClass = 'green'; isBullish = true;}
                else if (ratio < previousEthBtcRatio * 0.9925) { trendStatus = "Dalend"; colorClass = 'red'; isBearish = true;}
                else { trendStatus = "Stabiel";}
                trendText = `${ratio.toFixed(5)} (${trendStatus})`;
            } else { trendStatus = "Initieel"; }
            setIndicator(elementName, title, trendText, colorClass);
            if (previousEthBtcRatio === null && ratio !== undefined) previousEthBtcRatio = ratio;
            return { value: ratio, colorClass, name: title, detail: ratio.toFixed(5), detailFull: trendText, isBullish, isBearish };
        } else { 
            setIndicator(elementName, title, 'Prijsdata BTC/ETH mist', 'neutral', 'BTC/ETH prijsdata niet beschikbaar'); 
            return defaultReturn;
        }
    }


    function analyzeAndScore(results, relevantKeysAndWeights) {
        let score = 0; let totalWeightApplied = 0;
        let positiveFactors = []; let negativeFactors = []; let numValidSignals = 0;
        for (const key in relevantKeysAndWeights) {
            const indicator = results[key]; 
            const baseWeight = relevantKeysAndWeights[key]; 

            if (indicator && indicator.colorClass && indicator.colorClass !== 'neutral' && indicator.detail &&
                !indicator.detail.toLowerCase().includes('api key') && !indicator.detail.toLowerCase().includes('data mist') &&
                !indicator.detail.toLowerCase().includes('ongeldig') && !indicator.detail.toLowerCase().includes('laden') && 
                !indicator.detail.toLowerCase().includes('error') && 
                (indicator.value !== null || indicator.changePercent !== null || indicator.change !== null ) ) {
                numValidSignals++; 
                let currentScoreContribution = 0;
                let factorName = indicator.name || key;
                let factorDetailShort = indicator.detail.split('(')[0].trim() || indicator.value?.toFixed(2) || indicator.detail;
                let factorDetailForTooltip = indicator.detailFull || indicator.detail;
                
                if (indicator.colorClass === 'green') { 
                    currentScoreContribution = baseWeight; 
                } else if (indicator.colorClass === 'red') { 
                    currentScoreContribution = -baseWeight; 
                }
                
                score += currentScoreContribution; 
                totalWeightApplied += baseWeight; 
                
                if (currentScoreContribution > 0) { 
                    positiveFactors.push({ name: factorName, detail: factorDetailShort, detailFull: factorDetailForTooltip }); 
                } else if (currentScoreContribution < 0) { 
                    negativeFactors.push({ name: factorName, detail: factorDetailShort, detailFull: factorDetailForTooltip }); 
                }
            }
        }
        const percentageScore = totalWeightApplied > 0 ? (score / totalWeightApplied) * 100 : 0;
        return { percentageScore, positiveFactors, negativeFactors, numSignals: numValidSignals };
    }

    function updateGeneralMarketCondition(results) {
        const weights = {
            m2Trend: 1, interest10yrTrend: 1.5, yieldCurve: 2, unemploymentTrend: 1, 
            inflationTrend: 1.2, ppiTrend: 1.0, breakeven10yrTrend: 1.0,
            retailSalesTrend: 1, ismPmiTrend: 1.5, 
            dxyTrend: 1.2, goldTrend: 0.5, oilTrend: 0.7, copperTrend: 0.8,
            bondSpreadsTrend: 1.5, 
            cryptoFearGreed: 0.6, stockFearGreedVIX: 1.0, 
            sp500Trend: 1, nasdaq100Trend: 1, russell2000Trend: 0.8,
            btcPriceTrend: 0.5, ethPriceTrend: 0.5 
        };
        const analysis = analyzeAndScore(results, weights); let conditionText = "Neutraal / Gemengd";
        let strategyHint = "Markt is gemengd. Wees selectief, focus op sterke S/R niveaus.";

        const minSignalsForFullAnalysis = 10; 
        const anyKeyMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === '' || FMP_API_KEY === '';
        
        if (analysis.numSignals < minSignalsForFullAnalysis && anyKeyMissing ) { 
            conditionText = "API Key(s) Mist voor Volledige Analyse"; 
            strategyHint = "Configureer alle API keys voor volledige analyse.";
        } else if (analysis.numSignals < 5) { 
            conditionText = "Onvoldoende Data voor Analyse"; 
            strategyHint = "Wacht op meer data of controleer API verbindingen.";
        } else if (analysis.percentageScore > 55) {
            conditionText = "Zeer Positief"; strategyHint = "Marktcondities zijn zeer gunstig. Overweeg long posities op sterke trends.";
        } else if (analysis.percentageScore > 15) {
            conditionText = "Positief"; strategyHint = "Marktcondities zijn positief. Zoek naar long setups, let op confirmatie.";
        } else if (analysis.percentageScore < -55) {
            conditionText = "Zeer Negatief"; strategyHint = "Marktcondities zijn zeer ongunstig. Overweeg short posities of cash aanhouden.";
        } else if (analysis.percentageScore < -15) {
            conditionText = "Negatief"; strategyHint = "Marktcondities zijn negatief. Wees voorzichtig, zoek naar short setups of blijf aan de zijlijn.";
        }
        setMarketConditionCard('generalMarketCondition', 'generalMarketText', 'generalMarketFactors', 'generalMarketStrategy', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals, strategyHint);
    }

    function updateCryptoMarketCondition(results) {
        const cryptoWeights = {
            cryptoFearGreed: 1.5, btcPriceTrend: 1.2, ethPriceTrend: 1.2,
            altcoinMarketCapTrend: 1
            // btcDominanceTrend, ethDominanceTrend, ethBtcRatioTrend wegen mee via bitcoinAltcoinSentiment
        };
        const analysis = analyzeAndScore(results, cryptoWeights); 
        let conditionText = "Crypto Neutraal";
        let strategyHint = "Crypto markt neutraal. Zoek naar specifieke altcoin/BTC kansen of duidelijke breakouts.";

        if (analysis.numSignals < 3) { 
            conditionText = "Crypto Onvoldoende Data"; 
            strategyHint = "Onvoldoende data voor crypto analyse. Wacht op meer signalen.";
        } else if (analysis.percentageScore > 55) {
            conditionText = "Crypto Zeer Bullish"; strategyHint = "Crypto zeer bullish! Focus op long posities, vooral altcoins als sentiment meezit.";
        } else if (analysis.percentageScore > 15) {
            conditionText = "Crypto Bullish"; strategyHint = "Crypto bullish. Zoek naar dips om in te stappen of breakouts.";
        } else if (analysis.percentageScore < -55) {
            conditionText = "Crypto Zeer Bearish"; strategyHint = "Crypto zeer bearish. Wees extreem voorzichtig, overweeg shorts of blijf uit de markt.";
        } else if (analysis.percentageScore < -15) {
            conditionText = "Crypto Bearish"; strategyHint = "Crypto bearish. Wees voorzichtig met longs. Shorts op zwakte overwegen.";
        }
        setMarketConditionCard('cryptoMarketCondition', 'cryptoMarketText', 'cryptoMarketFactors', 'cryptoMarketStrategy', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals, strategyHint);
        
        // Bitcoin vs Altcoin Sentiment blijft zoals het was
        let btcAltScore = 0; let btcAltDetailParts = [];
        if (results.btcDominanceTrend && results.btcDominanceTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("BTC.Dâ†“");}
        else if (results.btcDominanceTrend && results.btcDominanceTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("BTC.Dâ†‘");}

        if (results.altcoinMarketCapTrend && results.altcoinMarketCapTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("AltMCâ†‘");}
        else if (results.altcoinMarketCapTrend && results.altcoinMarketCapTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("AltMCâ†“");}

        if (results.ethBtcRatioTrend && results.ethBtcRatioTrend.colorClass === 'green') { btcAltScore++; btcAltDetailParts.push("ETH/BTCâ†‘");}
        else if (results.ethBtcRatioTrend && results.ethBtcRatioTrend.colorClass === 'red') { btcAltScore--; btcAltDetailParts.push("ETH/BTCâ†“");}
        
        let btcAltText = "Neutraal"; let btcAltColor = "yellow";
        const allApisConfigured = FRED_API_KEY && FINNHUB_API_KEY && FMP_API_KEY; // Check of keys er zijn
        if (btcAltDetailParts.length < 2 && allApisConfigured && (previousBtcDom !== null && previousAltCap !== null && previousEthBtcRatio !== null )) { /* Trends moeten eerst geladen zijn voor een goede check */
            btcAltText = "Onvoldoende Data"; btcAltColor = "neutral";
        } else if (btcAltDetailParts.length < 1 && !allApisConfigured) {
             btcAltText = "API Keys?"; btcAltColor = "neutral";
        } else if (previousBtcDom === null || previousAltCap === null || previousEthBtcRatio === null) { 
             btcAltText = "Initieel..."; btcAltColor = "neutral"; 
        }
        else if (btcAltScore >= 2) { btcAltText = "Altcoin Gunstig"; btcAltColor = "green"; }
        else if (btcAltScore <= -1) { btcAltText = "Bitcoin Gunstiger"; btcAltColor = "red"; } 
        
        const detailString = btcAltDetailParts.length > 0 ? `(${btcAltDetailParts.slice(0,3).join(', ')})` : (allApisConfigured ? "(Wacht op trends)" : "");
        setIndicator('bitcoinAltcoinSentiment', 'Bitcoin vs. Altcoin Sentiment', `${btcAltText} ${detailString}`, btcAltColor);
    }

    function updateStockMarketCondition(results) {
        const weights = {
            sp500Trend: 1.2, nasdaq100Trend: 1.2, russell2000Trend: 1.0,
            stockFearGreedVIX: 1.5, yieldCurve: 1.5, 
            ismPmiTrend: 1.2, bondSpreadsTrend: 1, interest10yrTrend: 1, retailSalesTrend: 0.8, 
            unemploymentTrend: 0.5, ppiTrend: 0.7, breakeven10yrTrend: 0.7, copperTrend: 0.6
        };
        const analysis = analyzeAndScore(results, weights); 
        let conditionText = "Aandelen Neutraal";
        let strategyHint = "Aandelenmarkt neutraal. Focus op sectorrotatie of individuele stock picking.";

        const minSignalsForStocks = 6; 
        const relevantKeysMissing = FRED_API_KEY === '' || FINNHUB_API_KEY === ''; 
         if (analysis.numSignals < minSignalsForStocks && relevantKeysMissing ) { 
            conditionText = "API Key(s) Mist voor Analyse";
            strategyHint = "Configureer API keys voor volledige aandelenanalyse."; 
        } else if (analysis.numSignals < 4) { 
            conditionText = "Aandelen Onvoldoende Data";
            strategyHint = "Onvoldoende data voor aandelenanalyse."; 
        } else if (analysis.percentageScore > 55) {
            conditionText = "Aandelen Zeer Bullish"; strategyHint = "Aandelen zeer bullish. Overweeg long posities in sterke sectoren/aandelen.";
        } else if (analysis.percentageScore > 15) {
            conditionText = "Aandelen Bullish"; strategyHint = "Aandelen bullish. Goed instapmoment voor longs op sterke namen.";
        } else if (analysis.percentageScore < -55) {
            conditionText = "Aandelen Zeer Bearish"; strategyHint = "Aandelen zeer bearish. Overweeg short posities of cash. Wees defensief.";
        } else if (analysis.percentageScore < -15) {
            conditionText = "Aandelen Bearish"; strategyHint = "Aandelen bearish. Voorzichtig met longs. Overweeg defensieve posities.";
        }
        setMarketConditionCard('stockMarketCondition', 'stockMarketText', 'stockMarketFactors', 'stockMarketStrategy', analysis.percentageScore, conditionText, analysis.positiveFactors, analysis.negativeFactors, analysis.numSignals, strategyHint);
    }

    async function loadDashboardData() {
        console.log("loadDashboardData gestart...");
        document.getElementById('lastUpdated').textContent = `Laden... ${formatDate(new Date())}`;
        let results = {};

        const initialPromises = [
            fetchFredSeries('M2SL', 'm2Trend', 'M2 Geldhoeveelheid', true, " T USD", 1/1000).then(r => results.m2Trend = r),
            fetchFredSeries('DGS10', 'interest10yrTrend', '10jr Rente', false, "%").then(r => results.interest10yrTrend = r), 
            fetchFredSeries('DGS2', 'interest2yrTrend', '2jr Rente', false, "%").then(r => results.interest2yrTrend = r),       
            fetchFredSeries('UNRATE', 'unemploymentTrend', 'Werkloosheid', false, "%").then(r => results.unemploymentTrend = r), 
            fetchFredSeries('CPIAUCSL', 'inflationTrend', 'Inflatie (CPI Index)', false, " (Index)").then(r => results.inflationTrend = r), 
            fetchFredSeries('PPIACO', 'ppiTrend', 'PPI Trend', false, " (Index)").then(r => results.ppiTrend = r),
            fetchFredSeries('T10YIE', 'breakeven10yrTrend', '10jr Inflatieverwachting', false, "%").then(r => results.breakeven10yrTrend = r),
            fetchFredSeries('RRSFS', 'retailSalesTrend', 'Retail Sales', true, " B USD", 1/1000).then(r => results.retailSalesTrend = r),
            fetchFredSeries('PMI', 'ismPmiTrend', 'ISM PMI', true, "", 1, 50).then(r => results.ismPmiTrend = r), 
            
            fetchFmpQuote('DX-Y.NYB', 'dxyTrend', 'US Dollar Index (DXY)', false, true).then(r => results.dxyTrend = r),
            fetchFinnhubQuote('GLD', 'goldTrend', 'Goud ETF (GLD)', true, false).then(r => results.goldTrend = r), 
            fetchFinnhubQuote('USO', 'oilTrend', 'Olie ETF (USO)', false, false).then(r => results.oilTrend = r),
            fetchFinnhubQuote('CPER', 'copperTrend', 'Koper ETF (CPER)', true, false).then(r => results.copperTrend = r), 
            fetchFredSeries('BAMLH0A0HYM2', 'bondSpreadsTrend', 'HY Bond Spreads', false, "%").then(r => results.bondSpreadsTrend = r), 
            
            fetchCryptoFearGreed().then(r => results.cryptoFearGreed = r), 
            fetchFinnhubQuote('^VIX', 'stockFearGreedVIX', 'Aandelen F&G (VIX)', false, false).then(r => results.stockFearGreedVIX = r), 
            
            fetchCryptoPrice('bitcoin', 'btcPriceTrend', 'Bitcoin Prijs').then(r => results.btcPriceTrend = r),
            fetchCryptoPrice('ethereum', 'ethPriceTrend', 'Ethereum Prijs').then(r => results.ethPriceTrend = r),
            
            fetchFinnhubQuote('SPY', 'sp500Trend', 'S&P 500 (SPY ETF)', true, true).then(r => results.sp500Trend = r),
            fetchFinnhubQuote('QQQ', 'nasdaq100Trend', 'Nasdaq 100 (QQQ ETF)', true, true).then(r => results.nasdaq100Trend = r),
            fetchFinnhubQuote('IWM', 'russell2000Trend', 'Russell 2000 (IWM ETF)', true, true).then(r => results.russell2000Trend = r)
        ];

        console.log("Wachten op Promise.allSettled...", initialPromises.length, "promises");
        const allSettledResults = await Promise.allSettled(initialPromises);
        console.log("Promise.allSettled voltooid.");

        allSettledResults.forEach((result, index) => {
            if (result.status === 'rejected') {
                console.error(`Promise op index ${index} (data-ophaling) is mislukt:`, result.reason);
            }
        });

        console.log("Verwerken van afgeleide indicatoren (Yield Curve, Fed Stance)...");
        // Yield Curve (blijft hetzelfde)
        if (results.interest10yrTrend && results.interest10yrTrend.value !== null && results.interest10yrTrend.colorClass !== 'neutral' &&
            results.interest2yrTrend && results.interest2yrTrend.value !== null && results.interest2yrTrend.colorClass !== 'neutral') {
            const i10yr = results.interest10yrTrend; const i2yr = results.interest2yrTrend;
            const yieldSpread = i10yr.value - i2yr.value;
            let prevYieldSpread = null;
            if (i10yr.change !== null && i2yr.change !== null && i10yr.value !== null && i2yr.value !== null) {
                 const prev10yr = i10yr.value - i10yr.change;
                 const prev2yr = i2yr.value - i2yr.change;
                 prevYieldSpread = prev10yr - prev2yr;
            }
            let ycColor = 'yellow', ycTrend = "Stabiel";
            if (yieldSpread < 0) { ycColor = 'red'; ycTrend = "INVERS!";} 
            else if (yieldSpread < 0.20) { ycColor = 'yellow'; ycTrend = "Vlak";} 
            else if (prevYieldSpread !== null && yieldSpread > prevYieldSpread + 0.03) { ycColor = 'green'; ycTrend = "Versteilend";} 
            else if (prevYieldSpread !== null && yieldSpread < prevYieldSpread - 0.03) { ycColor = 'yellow'; ycTrend = "Afvlakkend";} 
            else if (yieldSpread >= 0.20) { ycColor = 'green'; ycTrend = "Normaal";} 
            let ycText = `${yieldSpread.toFixed(2)}% (${ycTrend})`;
            setIndicator('yieldCurve', 'Yield Curve (10j - 2j)', ycText, ycColor);
            results.yieldCurve = { value: yieldSpread, colorClass: ycColor, name: "Yield Curve", detail: `${yieldSpread.toFixed(2)}%`, detailFull: ycText, positiveChangeIsGood: (ycColor==='green') };
        } else {
            let errorMsg = "10j/2j data incompleet";
            if (!FRED_API_KEY) errorMsg = "Koppel FRED API Key";
            setIndicator('yieldCurve', 'Yield Curve', 'Rentedata mist', 'neutral', errorMsg);
            results.yieldCurve = {value:null, colorClass:'neutral', name:"Yield Curve", detail:"Rentedata mist", detailFull:"Rentedata 10j/2j mist voor Yield Curve berekening."};
        }

        // Fed Stance (blijft hetzelfde)
        console.log("Afleiden Fed Stance...");
        const i10yrData = results.interest10yrTrend;
        if (i10yrData && i10yrData.value !== null && i10yrData.change !== null && i10yrData.colorClass !== 'neutral' && !i10yrData.detail.toLowerCase().includes('api key')) {
            let fedColor = 'yellow';
            let fedText = "Neutraal";
            if (i10yrData.colorClass === 'red') { 
                fedText = "Verkrappend (Hawkish)"; fedColor = 'red';
            } else if (i10yrData.colorClass === 'green') { 
                fedText = "Verruimend (Dovish)"; fedColor = 'green';
            } else { 
                fedText = "Neutraal / Stabiel"; fedColor = 'yellow';
            }
            setIndicator('fedStance', 'Fed Beleid Stance', fedText, fedColor);
            results.fedStance = { value: i10yrData.change, colorClass: fedColor, name: "Fed Beleid", detail: fedText, detailFull: fedText, positiveChangeIsGood: (fedColor === 'green') };
        } else {
            let errorMsg = "10j Rentedata incompleet voor Fed Stance.";
            if (!FRED_API_KEY) errorMsg = "Koppel FRED API Key";
            else if (i10yrData && i10yrData.detail.toLowerCase().includes('api key')) errorMsg = "Koppel FRED API Key";
            else if (i10yrData && i10yrData.detail.toLowerCase().includes('error')) errorMsg = i10yrData.detailFull || "Data Error 10j Rente";

            setIndicator('fedStance', 'Fed Beleid Stance', 'Data onbeschikbaar', 'neutral', errorMsg);
            results.fedStance = { value: null, colorClass: 'neutral', name: "Fed Beleid", detail: "Data onbeschikbaar", detailFull: errorMsg };
        }


        console.log("Ophalen CoinGecko global data...");
        const cgData = await fetchCoinGeckoGlobalData();
        if (cgData) { Object.assign(results, cgData); }

        console.log("Berekenen ETH/BTC Ratio...");
        results.ethBtcRatioTrend = await calculateEthBtcRatio(results.btcPriceTrend, results.ethPriceTrend);

        console.log("Updaten van marktconditiekaarten...");
        updateGeneralMarketCondition(results);
        updateCryptoMarketCondition(results);
        updateStockMarketCondition(results);

        document.getElementById('lastUpdated').textContent = `Laatst bijgewerkt: ${formatDate(new Date())}`;
        console.log("loadDashboardData voltooid.");
    }

    // --- START Inklapbare sectie JavaScript ---
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.collapsible-trigger').forEach(trigger => {
            trigger.style.cursor = 'pointer';
            const content = trigger.nextElementSibling; // .collapsible-content

            // Initieel collaboren, behalve de eerste paar kaarten misschien
            // Voor nu: collaboreer alles behalve de eerste (Macro)
            // if (!trigger.closest('.card').querySelector('#m2Trend')) { // Simpele check voor de eerste kaart
            //    trigger.parentElement.classList.add('collapsed');
            //    if (content) content.style.display = 'none';
            // }


            trigger.addEventListener('click', function() {
                this.parentElement.classList.toggle('collapsed');
                if (content) {
                    if (content.style.display === 'none' || content.style.display === '') {
                        content.style.display = 'block'; // Of de originele display waarde als je complexere layouts hebt
                    } else {
                        content.style.display = 'none';
                    }
                }
            });
        });
        // Optioneel: Initieel collaboren van alle secties behalve de eerste
         const allCards = document.querySelectorAll('.grid-container .card, .tradingview-container.card');
         allCards.forEach((card, index) => {
            if (index > 0) { // Collaboreer alles behalve de eerste kaart in de grid
                const trigger = card.querySelector('.collapsible-trigger');
                const content = card.querySelector('.collapsible-content');
                if (trigger && content) {
                    card.classList.add('collapsed');
                    content.style.display = 'none';
                }
            }
         });


    });
    // --- EINDE Inklapbare sectie JavaScript ---


    console.log("Event listener voor window.onload wordt ingesteld.");
    window.onload = loadDashboardData;
    // setInterval(loadDashboardData, 15 * 60 * 1000); 

    console.log("Script einde bereikt (synchroon deel).");
</script>
</body>
</html>
